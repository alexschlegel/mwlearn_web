// Generated by CoffeeScript 1.8.0
(function() {
  var MRT, aan, add, around, capitalize, contains, copy, dec2frac, divide, extend, fixAngle, forceArray, mean, merge, mod, msPerT, mult, objPath, pickFrom, randomize, remove, rotate, setdiff, smult, sub, sum, swap, unique, wordCount, zpad,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.doDebug = function() {
    return null;
  };

  window.obj2str = function(obj, indent, recursion_limit) {
    var key, pad, pre, str, val;
    if (indent == null) {
      indent = 0;
    }
    if (recursion_limit == null) {
      recursion_limit = 5;
    }
    if (recursion_limit < 0) {
      return '...';
    } else if ((obj != null) && (typeof obj === 'object')) {
      pre = (indent > 0 ? "\n" : "");
      pad = zpad('', indent, " ");
      str = [];
      for (key in obj) {
        val = obj[key];
        str.push("" + pad + key + ":" + (obj2str(val, indent + 1, recursion_limit - 1)));
      }
      return pre + str.join("\n");
    } else {
      return obj;
    }
  };

  objPath = function() {
    var el, obj, path, x, _i, _len;
    obj = arguments[0], path = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    x = obj;
    for (_i = 0, _len = path.length; _i < _len; _i++) {
      el = path[_i];
      if (x != null) {
        x = x[el];
      } else {
        break;
      }
    }
    return x;
  };

  window.getClass = function(obj) {
    if (obj != null) {
      return obj.constructor.name;
    } else {
      return null;
    }
  };

  zpad = function(x, n, chr) {
    if (chr == null) {
      chr = '0';
    }
    while (('' + x).length < n) {
      x = chr + x;
    }
    return x;
  };

  extend = function(obj, prop) {
    var key, val;
    for (key in prop) {
      val = prop[key];
      obj[key] = val;
    }
    return obj;
  };

  copy = function(x, deep) {
    var key, val, y, _i, _len, _results;
    if (deep == null) {
      deep = false;
    }
    switch (getClass(x)) {
      case 'Object':
        if (deep) {
          y = {};
          for (key in x) {
            val = x[key];
            y[key] = copy(val, true);
          }
          return y;
        } else {
          return extend({}, x);
        }
        break;
      case 'Array':
        if (deep) {
          _results = [];
          for (_i = 0, _len = x.length; _i < _len; _i++) {
            val = x[_i];
            _results.push(copy(val, true));
          }
          return _results;
        } else {
          return x.slice(0);
        }
        break;
      default:
        return x;
    }
  };

  merge = function(obj1, obj2) {
    return extend(copy(obj1), obj2);
  };

  remove = function(obj, keys) {
    var key, objc, _i, _len;
    objc = copy(obj);
    for (_i = 0, _len = keys.length; _i < _len; _i++) {
      key = keys[_i];
      delete objc[key];
    }
    return objc;
  };

  swap = function(x, i1, i2) {
    var tmp;
    tmp = x[i1];
    x[i1] = x[i2];
    return x[i2] = tmp;
  };

  sum = function(x, s, e) {
    var n;
    if (s == null) {
      s = 0;
    }
    if (e == null) {
      e = null;
    }
    n = x.length;
    if ((0 <= s && s < n) && ((e == null) || s <= e)) {
      return x[s] + sum(x, s + 1, e != null ? e : n - 1);
    } else {
      return 0;
    }
  };

  add = function(a, b) {
    var idx, _i, _ref, _results;
    _results = [];
    for (idx = _i = 0, _ref = a.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; idx = 0 <= _ref ? ++_i : --_i) {
      _results.push(a[idx] + b[idx]);
    }
    return _results;
  };

  sub = function(a, b) {
    var idx, _i, _ref, _results;
    _results = [];
    for (idx = _i = 0, _ref = a.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; idx = 0 <= _ref ? ++_i : --_i) {
      _results.push(a[idx] - b[idx]);
    }
    return _results;
  };

  mult = function(a, b) {
    var idx, _i, _ref, _results;
    _results = [];
    for (idx = _i = 0, _ref = a.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; idx = 0 <= _ref ? ++_i : --_i) {
      _results.push(a[idx] * b[idx]);
    }
    return _results;
  };

  mean = function(a) {
    return sum(a) / a.length;
  };

  divide = function(a, b) {
    var idx, _i, _ref, _results;
    _results = [];
    for (idx = _i = 0, _ref = a.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; idx = 0 <= _ref ? ++_i : --_i) {
      _results.push(a[idx] / b[idx]);
    }
    return _results;
  };

  smult = function(a, b) {
    var idx, _i, _ref, _results;
    _results = [];
    for (idx = _i = 0, _ref = a.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; idx = 0 <= _ref ? ++_i : --_i) {
      _results.push(a[idx] * b);
    }
    return _results;
  };

  mod = function(x, n) {
    var r;
    r = x % n;
    if (r < 0) {
      return r + n;
    } else {
      return r;
    }
  };

  around = function(x) {
    var e, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = x.length; _i < _len; _i++) {
      e = x[_i];
      _results.push(Math.round(e));
    }
    return _results;
  };

  window.nearest = function(x, ref) {
    var df, dfMin, i, r, _i, _ref;
    df = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = ref.length; _i < _len; _i++) {
        r = ref[_i];
        _results.push(Math.abs(x - r));
      }
      return _results;
    })();
    dfMin = Math.min.apply(Math, df);
    for (i = _i = 0, _ref = ref.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (df[i] === dfMin) {
        return ref[i];
      }
    }
  };

  window.randomInt = function(mn, mx) {
    return Math.floor(Math.random() * (mx - mn + 1)) + mn;
  };

  randomize = function(x) {
    var iCur, iRnd, _results;
    iCur = x.length;
    _results = [];
    while (iCur !== 0) {
      iRnd = randomInt(0, iCur - 1);
      iCur -= 1;
      _results.push(swap(x, iCur, iRnd));
    }
    return _results;
  };

  pickFrom = function(x) {
    return x[randomInt(0, x.length - 1)];
  };

  rotate = function(p, theta, about) {
    var a, cs, sn, x, y;
    if (about == null) {
      about = [0, 0];
    }
    a = Math.PI * theta / 180;
    cs = Math.cos(a);
    sn = Math.sin(a);
    x = p[0] - about[0];
    y = p[1] - about[1];
    return p = [x * cs - y * sn + about[0], x * sn + y * cs + about[1]];
  };

  window.equals = function(x, y) {
    var idx, _i, _ref;
    if (Array.isArray(x) && Array.isArray(y)) {
      if (x.length === y.length) {
        for (idx = _i = 0, _ref = x.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; idx = 0 <= _ref ? ++_i : --_i) {
          if (!equals(x[idx], y[idx])) {
            return false;
          }
        }
        return true;
      } else {
        return false;
      }
    } else {
      return x === y;
    }
  };

  window.find = function(x, v) {
    var e, f, i, _i, _len;
    f = [];
    for (i = _i = 0, _len = x.length; _i < _len; i = ++_i) {
      e = x[i];
      if (equals(e, v)) {
        f.push(i);
      }
    }
    return f;
  };

  setdiff = function(x, d) {
    var e, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = x.length; _i < _len; _i++) {
      e = x[_i];
      if (!equals(e, d)) {
        _results.push(e);
      }
    }
    return _results;
  };

  fixAngle = function(a) {
    a = mod(a, 360);
    if (a > 180) {
      return a - 360;
    } else {
      return a;
    }
  };

  aan = function(str) {
    if (str.length === 0 || find("aeiou", str[0]).length === 0) {
      return 'a';
    } else {
      return 'an';
    }
  };

  capitalize = function(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  };

  contains = function(x, v) {
    var e, _i, _len;
    for (_i = 0, _len = x.length; _i < _len; _i++) {
      e = x[_i];
      if (equals(e, v)) {
        return true;
      }
    }
    return false;
  };

  unique = function(x) {
    var e, u, _i, _len;
    u = [];
    for (_i = 0, _len = x.length; _i < _len; _i++) {
      e = x[_i];
      if (!contains(u, e)) {
        u.push(e);
      }
    }
    return u;
  };

  forceArray = function(a) {
    if (a != null) {
      if (Array.isArray(a)) {
        return a;
      } else {
        return [a];
      }
    } else {
      return a;
    }
  };

  wordCount = function(str) {
    return str.split(' ').length;
  };

  msPerT = function(unit) {
    switch (unit) {
      case 'day':
        return 86400000;
      case 'hour':
      case 'hr':
      case 'h':
        return 3600000;
      case 'minute':
      case 'min':
      case 'm':
        return 60000;
      case 'second':
      case 'sec':
      case 's':
        return 1000;
      case 'millisecond':
      case 'msec':
      case 'ms':
        return 1;
      case 'dayminus10minutes':
        return 85800000;
      default:
        throw 'Invalid unit';
    }
  };

  window.convertTime = function(t, unitFrom, unitTo) {
    return t * msPerT(unitFrom) / msPerT(unitTo);
  };

  window.time2str = function(t, showms) {
    var hours, minutes, seconds, strHours, strMS, strMinutes, strSeconds;
    if (showms == null) {
      showms = false;
    }
    hours = Math.floor(convertTime(t, 'ms', 'hour'));
    t -= convertTime(hours, 'hour', 'ms');
    minutes = Math.floor(convertTime(t, 'ms', 'minute'));
    t -= convertTime(minutes, 'minute', 'ms');
    seconds = Math.floor(convertTime(t, 'ms', 'second'));
    t -= convertTime(seconds, 'second', 'ms');
    strHours = hours > 0 ? "" + (zpad(hours, 2)) + ":" : '';
    strMinutes = "" + (zpad(minutes, 2)) + ":";
    strSeconds = zpad(seconds, 2);
    strMS = showms ? "." + t : '';
    return "" + strHours + strMinutes + strSeconds + strMS;
  };

  window.squareGrid = function(n) {
    var col, cr, i, iMax, rc, row, score, x, _i, _j, _ref, _ref1, _results;
    rc = (function() {
      _results = [];
      for (var _i = 1, _ref = Math.max(1, Math.floor(Math.sqrt(n))); 1 <= _ref ? _i <= _ref : _i >= _ref; 1 <= _ref ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this);
    cr = (function() {
      var _j, _len, _results1;
      _results1 = [];
      for (_j = 0, _len = rc.length; _j < _len; _j++) {
        x = rc[_j];
        _results1.push(Math.max(1, Math.ceil(n / x)));
      }
      return _results1;
    })();
    score = (function() {
      var _j, _ref1, _results1;
      _results1 = [];
      for (i = _j = 0, _ref1 = rc.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        _results1.push(1 / ((1 + rc[i] * cr[i] - n) * Math.pow(1 + cr[i] - rc[i], 3)));
      }
      return _results1;
    })();
    iMax = 0;
    for (i = _j = 1, _ref1 = score.length - 1; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
      if (score[i] > score[iMax]) {
        iMax = i;
      }
    }
    row = Math.min(rc[iMax], cr[iMax]);
    col = Math.max(rc[iMax], cr[iMax]);
    return [row, col];
  };

  dec2frac = function(x, tolerance) {
    var a, b, d1, d2, n1, n2, _ref, _ref1, _ref2, _ref3;
    if (tolerance == null) {
      tolerance = 0.000001;
    }

    /*adapted from http://jonisalonen.com/2012/converting-decimal-numbers-to-ratios/ */
    _ref = [1, 0], n1 = _ref[0], n2 = _ref[1];
    _ref1 = [0, 1], d1 = _ref1[0], d2 = _ref1[1];
    b = x;
    while (true) {
      a = Math.floor(b);
      _ref2 = [a * n1 + n2, n1], n1 = _ref2[0], n2 = _ref2[1];
      _ref3 = [a * d1 + d2, d1], d1 = _ref3[0], d2 = _ref3[1];
      b = 1 / (b - a);
      if (Math.abs(x - n1 / d1) <= x * tolerance) {
        break;
      }
    }
    return [n1, d1];
  };

  window.MRT = MRT = (function() {
    var MRTClass, MRTClassColor, MRTClassData, MRTClassDebugger, MRTClassExec, MRTClassInput, MRTClassParam, MRTClassQueue, MRTClassSession, MRTClassShow, MRTClassTime;

    MRT.prototype._seed_default = 'i am a seed';

    MRT.prototype._seed = null;

    MRT.prototype._background = null;

    MRT.prototype._ready = false;

    MRT.prototype.default_subject = '';

    MRT.prototype.subject = null;

    MRT.prototype.csrf = null;

    MRT.prototype.container = null;

    MRT.prototype.el = null;

    MRT.prototype.im = null;

    MRT.prototype.background = null;

    MRT.prototype.debug = false;

    function MRT(options) {
      var defaults, images, _ref;
      if (options == null) {
        options = {};
      }
      this.debug = (_ref = options.debug) != null ? _ref : false;
      defaults = {
        seed: this._seed_default,
        container: 'experiment',
        background: 'gray',
        background_stroke: 'none',
        default_subject: this.debug ? 'test' : '',
        images: [],
        loadimages: true,
        fixation: [
          "Circle", [
            {
              color: "red",
              r: 5
            }
          ]
        ],
        run_session: !this.debug
      };
      options = merge(defaults, options);
      this.setSeed(options.seed);
      this.csrf = options.csrf;
      this.default_subject = options.default_subject;
      this.container = options.container;
      this.background = options.background;
      this.im = {};
      this.paper = Raphael(this.container);
      this.show = this.Show();
      this.input = this.Input();
      this.time = this.Time();
      this.color = this.Color();
      this.exec = this.Exec();
      this.queue = this.Queue();
      this._background = this.show.Rectangle({
        color: this.background,
        width: this.width(),
        height: this.height(),
        stroke: options.background_stroke,
        "stroke-width": 16
      });
      this.data = this.Data();
      this.session = this.Session();
      this.param = this.Param();
      this.dbg = this.Debugger();
      if (options.loadimages) {
        images = options.images;
        if (images.length) {
          this.LoadImages(images);
        }
      }
      if (options.run_session) {
        this.queue.add('session_run', (function(_this) {
          return function() {
            return _this.session.run();
          };
        })(this));
      }
      this.ready(true);
    }

    MRT.prototype.width = function() {
      return this.paper.width;
    };

    MRT.prototype.height = function() {
      return this.paper.height;
    };

    MRT.prototype.clear = function() {
      return this.paper.clear();
    };

    MRT.prototype.ready = function(state) {
      if (state == null) {
        state = null;
      }
      if (state != null) {
        this._ready = state;
        if (this._ready) {
          this.queue["do"]();
        }
      }
      return this._ready;
    };

    MRT.prototype.resize = function() {
      return document.location.reload(true);
    };

    MRT.prototype.LoadImages = function(images) {
      var f, fUpdate, idx, nLoaded, p, qName, _i, _ref, _results;
      nLoaded = 0;
      p = this.show.Progress("Loading Images", {
        steps: 20
      });
      fUpdate = (function(_this) {
        return function() {
          return p.update(++nLoaded / images.length);
        };
      })(this);
      _results = [];
      for (idx = _i = 0, _ref = images.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; idx = 0 <= _ref ? ++_i : --_i) {
        f = idx === images.length - 1 ? ((function(_this) {
          return function() {
            return fUpdate();
          };
        })(this)) : fUpdate;
        qName = "image_" + images[idx];
        this.queue.add(qName, f, {
          "do": false
        });
        this.im[images[idx]] = new Image();
        this.im[images[idx]].src = images[idx];
        _results.push(this.im[images[idx]].onload = ((function(_this) {
          return function(name) {
            return function() {
              return _this.queue["do"](name);
            };
          };
        })(this))(qName));
      }
      return _results;
    };

    MRT.prototype.visible = function(state) {
      var el, elements, _i, _len, _results;
      elements = ["\#" + this.container];
      _results = [];
      for (_i = 0, _len = elements.length; _i < _len; _i++) {
        el = elements[_i];
        _results.push(state ? $(el).show() : $(el).hide());
      }
      return _results;
    };

    MRT.prototype.getSeed = function() {
      return this._seed;
    };

    MRT.prototype.setSeed = function(seed) {
      if (seed == null) {
        seed = null;
      }
      if (seed != null) {
        this._seed = seed.length > 0 ? seed : this._seed_default;
      }
      return Math.seedrandom(this.getSeed());
    };

    MRT.prototype.MRTClass = MRTClass = (function() {
      MRTClass.prototype.root = null;

      function MRTClass(root) {
        this.root = root;
      }

      return MRTClass;

    })();

    MRT.prototype.Show = function() {
      return new MRTClassShow(this);
    };

    MRT.prototype.MRTClassShow = MRTClassShow = (function(_super) {
      var MRTClassShowChoice, MRTClassShowCircle, MRTClassShowColorMask, MRTClassShowCompoundStimulus, MRTClassShowDialog, MRTClassShowImage, MRTClassShowInstructions, MRTClassShowItemList, MRTClassShowLink, MRTClassShowOk, MRTClassShowPath, MRTClassShowProgress, MRTClassShowRectangle, MRTClassShowSMFigure, MRTClassShowSquare, MRTClassShowStimulus, MRTClassShowStimulusGrid, MRTClassShowTest, MRTClassShowText, MRTClassShowTimer, MRTClassShowX, MRTClassShowYesNo;

      __extends(MRTClassShow, _super);

      function MRTClassShow() {
        return MRTClassShow.__super__.constructor.apply(this, arguments);
      }

      MRTClassShow.prototype.Stimulus = function(options, addDefaults) {
        if (options == null) {
          options = {};
        }
        if (addDefaults == null) {
          addDefaults = true;
        }
        return new this.MRTClassShowStimulus(this.root, options, addDefaults);
      };

      MRTClassShow.prototype.MRTClassShowStimulus = MRTClassShowStimulus = (function(_super1) {
        __extends(MRTClassShowStimulus, _super1);

        MRTClassShowStimulus.prototype.element = null;

        MRTClassShowStimulus.prototype.handlers = null;

        MRTClassShowStimulus.prototype.auto_scale = 0;

        MRTClassShowStimulus.prototype._rotation = 0;

        MRTClassShowStimulus.prototype._scale = 1;

        MRTClassShowStimulus.prototype._translation = [0, 0];

        MRTClassShowStimulus.prototype._defaults = {
          x: 0,
          y: 0,
          width: 100,
          height: 100,
          color: "black"
        };

        MRTClassShowStimulus.prototype._show_state = true;

        MRTClassShowStimulus.prototype._mousedown = null;

        MRTClassShowStimulus.prototype._mouseup = null;

        MRTClassShowStimulus.prototype._mouseover = null;

        MRTClassShowStimulus.prototype._mouseout = null;

        function MRTClassShowStimulus(root, options, addDefaults) {
          var name, value, _ref;
          MRTClassShowStimulus.__super__.constructor.call(this, root);
          this.handlers = {};
          options = this.parseOptions(options, {}, addDefaults);
          this.auto_scale = (_ref = options.auto_scale) != null ? _ref : 1;
          for (name in options) {
            value = options[name];
            this.attr(name, value);
          }
        }

        MRTClassShowStimulus.prototype.parseOptions = function(options, defaults, addDefaults) {
          var def;
          if (defaults == null) {
            defaults = {};
          }
          if (addDefaults == null) {
            addDefaults = true;
          }
          def = addDefaults ? merge(this._defaults, defaults) : copy(defaults);
          if ((options.l != null) && (def.x != null)) {
            delete def.x;
          }
          if ((options.t != null) && (def.y != null)) {
            delete def.y;
          }
          return merge(def, options);
        };

        MRTClassShowStimulus.prototype.H_STRINGS = ['width', 'x', 'cx', 'l', 'cl', 'lc', 'h'];

        MRTClassShowStimulus.prototype.V_STRINGS = ['height', 'y', 'cy', 't', 'ct', 'tc', 'v'];

        MRTClassShowStimulus.prototype.isH = function(type) {
          return this.H_STRINGS.indexOf(type) !== -1;
        };

        MRTClassShowStimulus.prototype.isV = function(type) {
          return this.V_STRINGS.indexOf(type) !== -1;
        };

        MRTClassShowStimulus.prototype.addc = function(x, type) {
          if (type[0] === 'c') {
            return "c" + x;
          } else {
            return x;
          }
        };

        MRTClassShowStimulus.prototype.type2wh = function(type) {
          if (this.isH(type)) {
            return 'width';
          } else {
            return 'height';
          }
        };

        MRTClassShowStimulus.prototype.type2xy = function(type) {
          return this.addc((this.isH(type) ? 'x' : 'y'), type);
        };

        MRTClassShowStimulus.prototype.type2lt = function(type) {
          return this.addc((this.isH(type) ? 'l' : 't'), type);
        };

        MRTClassShowStimulus.prototype.type2hv = function(type) {
          if (this.isH(type)) {
            return 'h';
          } else if (this.isV(type)) {
            return 'v';
          } else {
            return 'other';
          }
        };

        MRTClassShowStimulus.prototype.x2lc = function(x) {
          return x + this.root.width() / 2;
        };

        MRTClassShowStimulus.prototype.lc2x = function(l) {
          return l - this.root.width() / 2;
        };

        MRTClassShowStimulus.prototype.y2tc = function(y) {
          return y + this.root.height() / 2;
        };

        MRTClassShowStimulus.prototype.tc2y = function(t) {
          return t - this.root.height() / 2;
        };

        MRTClassShowStimulus.prototype.x2l = function(x, width) {
          if (width == null) {
            width = null;
          }
          return this.x2lc(x) - (width != null ? width : this.attr("width")) / 2;
        };

        MRTClassShowStimulus.prototype.l2x = function(l, width) {
          if (width == null) {
            width = null;
          }
          return this.lc2x(l) + (width != null ? width : this.attr("width")) / 2;
        };

        MRTClassShowStimulus.prototype.y2t = function(y, height) {
          if (height == null) {
            height = null;
          }
          return this.y2tc(y) - (height != null ? height : this.attr("height")) / 2;
        };

        MRTClassShowStimulus.prototype.t2y = function(t, height) {
          if (height == null) {
            height = null;
          }
          return this.tc2y(t) + (height != null ? height : this.attr("height")) / 2;
        };

        MRTClassShowStimulus.prototype.xy2lt = function(v, xy) {
          if (this.isH(xy)) {
            return this.x2l(v);
          } else {
            return this.y2t(v);
          }
        };

        MRTClassShowStimulus.prototype.lt2xy = function(v, xy) {
          if (this.isH(xy)) {
            return this.l2x(v);
          } else {
            return this.t2y(v);
          }
        };

        MRTClassShowStimulus.prototype.xy2ltc = function(v, xy) {
          if (this.isH(xy)) {
            return this.x2lc(v);
          } else {
            return this.y2tc(v);
          }
        };

        MRTClassShowStimulus.prototype.ltc2xy = function(v, xy) {
          if (this.isH(xy)) {
            return this.lc2x(v);
          } else {
            return this.tc2y(v);
          }
        };

        MRTClassShowStimulus.prototype.extent = function(type) {
          switch (this.type2hv(type)) {
            case 'h':
              return this.root.width();
            case 'v':
              return this.root.height();
            default:
              return (this.root.height() + this.root.width()) / 2;
          }
        };

        MRTClassShowStimulus.prototype.norm2px = function(x, type) {
          return x * this.extent(type);
        };

        MRTClassShowStimulus.prototype.px2norm = function(x, type) {
          return x / this.extent(type);
        };

        MRTClassShowStimulus.prototype.maxBox = function() {
          var hMax, hTotal, wMax, wTotal;
          wTotal = this.root.width();
          hTotal = this.root.height();
          wMax = wTotal - 2 * Math.abs(this.attr('x'));
          hMax = hTotal - 2 * Math.abs(this.attr('y'));
          return [this.auto_scale * wMax, this.auto_scale * hMax];
        };

        MRTClassShowStimulus.prototype.attr = function(name, value) {
          var box, h, lt, r, ret, sCur, w, wh, xy;
          switch (name) {
            case "color":
              ret = this.element.attr("fill", value);
              break;
            case "width":
            case "height":
              if (value != null) {
                if (value === 'auto') {
                  this.attr('box', this.maxBox());
                } else {
                  sCur = this.element.attr(name);
                  this.element.attr(name, value);
                  xy = this.type2xy(name);
                  this.attr(xy, this.attr(xy) - (value - sCur) / 2);
                }
              } else {
                ret = this.element.attr(name);
              }
              break;
            case "x":
            case "y":
              lt = this.type2lt(name);
              if (value != null) {
                this.attr(lt, this.xy2lt(value, name));
              } else {
                ret = this.lt2xy(this.attr(lt), name);
              }
              break;
            case "l":
            case "t":
              xy = this.type2xy(name);
              if (value != null) {
                this.element.attr(xy, value);
              } else {
                ret = this.element.attr(xy);
              }
              break;
            case "cx":
            case "cy":
              wh = this.type2wh(name);
              if (value != null) {
                this.element.attr(name, this.xy2lt(value, name) + this.attr(wh) / 2);
              } else {
                ret = this.lt2xy(this.element.attr(name), name) - this.attr(wh) / 2;
              }
              break;
            case "lc":
            case "tc":
              lt = name[0];
              wh = this.type2wh(name);
              if (value != null) {
                this.attr(lt, value - this.attr(wh) / 2);
              } else {
                ret = this.attr(lt) + this.attr(wh) / 2;
              }
              break;
            case "mousedown":
            case "mouseup":
            case "mouseover":
            case "mouseout":
              if (value != null) {
                this["_" + name] = value;
                this.element[name](value);
              } else {
                ret = this["_" + name];
              }
              break;
            case "box":
              w = this.attr("width");
              h = this.attr("height");
              ret = box = [w, h];
              if (value != null) {
                if (!Array.isArray(value)) {
                  value = [value, value];
                }
                r = divide(value, box);
                if (r[0] < r[1]) {
                  this.attr("width", value[0]);
                  this.attr("height", h * r[0]);
                } else {
                  this.attr("width", w * r[1]);
                  this.attr("height", value[1]);
                }
              }
              break;
            case "show":
              if (value != null) {
                this._show_state = value;
                if (value) {
                  this.element.show();
                } else {
                  this.element.hide();
                }
              } else {
                ret = this._show_state;
              }
              break;
            default:
              ret = this.element.attr(name, value);
          }
          if (value != null) {
            return this;
          } else {
            return ret;
          }
        };

        MRTClassShowStimulus.prototype.contain = function() {
          var h, hTotal, l, t, w, wTotal;
          wTotal = this.root.width();
          hTotal = this.root.height();
          w = this.attr("width");
          h = this.attr("height");
          l = this.attr("l");
          t = this.attr("t");
          if (l + w > wTotal) {
            this.attr("box", [Math.max(0, 2 * (wTotal - (l + w / 2))), h]);
          } else if (l < 0) {
            this.attr("box", [Math.max(0, 2 * (l + w / 2)), h]);
          }
          if (t + h > hTotal) {
            return this.attr("box", [w, Math.max(0, 2 * (hTotal - (t + h / 2)))]);
          } else if (t < 0) {
            return this.attr("box", [w, Math.max(0, 2 * (t + h / 2))]);
          }
        };

        MRTClassShowStimulus.prototype._settransform = function() {
          return this.element.transform("r" + this._rotation + ",s" + this._scale + ",t" + this._translation);
        };

        MRTClassShowStimulus.prototype.rotate = function(a, xc, yc) {
          var r, theta, xDiff, yDiff;
          if (xc == null) {
            xc = null;
          }
          if (yc == null) {
            yc = null;
          }
          if ((xc != null) || (yc != null)) {
            xc = xc != null ? xc : this.attr("x");
            yc = yc != null ? yc : this.attr("y");
            xDiff = (this.attr("x")) - xc;
            yDiff = (this.attr("y")) - yc;
            r = Math.sqrt(Math.pow(xDiff, 2) + Math.pow(yDiff, 2));
            theta = Math.atan2(yDiff, xDiff);
            theta += a * Math.PI / 180;
            this.attr("x", r * Math.cos(theta) + xc);
            this.attr("y", r * Math.sin(theta) + yc);
          }
          this._rotation = (this._rotation + a) % 360;
          return this._settransform();
        };

        MRTClassShowStimulus.prototype.scale = function(s, xc, yc) {
          var r, theta, xDiff, yDiff;
          if (xc == null) {
            xc = null;
          }
          if (yc == null) {
            yc = null;
          }
          if ((xc != null) || (yc != null)) {
            xc = xc != null ? xc : this.attr("x");
            yc = yc != null ? yc : this.attr("y");
            xDiff = (this.attr("x")) - xc;
            yDiff = (this.attr("y")) - yc;
            r = Math.sqrt(Math.pow(xDiff, 2) + Math.pow(yDiff, 2));
            theta = Math.atan2(yDiff, xDiff);
            r *= s;
            this.attr("x", r * Math.cos(theta) + xc);
            this.attr("y", r * Math.sin(theta) + yc);
          }
          this._scale = s * this._scale;
          return this._settransform();
        };

        MRTClassShowStimulus.prototype.translate = function(x, y) {
          if (x == null) {
            x = 0;
          }
          if (y == null) {
            y = 0;
          }
          this._translation[0] += x;
          this._translation[1] += y;
          return this._settransform();
        };

        MRTClassShowStimulus.prototype.remove = function() {
          if (this.element != null) {
            this.element.remove();
            return this.element = null;
          }
        };

        MRTClassShowStimulus.prototype.mousedown = function(f) {
          return this.attr("mousedown", f);
        };

        MRTClassShowStimulus.prototype.mouseup = function(f) {
          return this.attr("mouseup", f);
        };

        MRTClassShowStimulus.prototype.mouseover = function(f) {
          return this.attr("mouseover", f);
        };

        MRTClassShowStimulus.prototype.mouseout = function(f) {
          return this.attr("mouseout", f);
        };

        MRTClassShowStimulus.prototype.show = function(state) {
          if (state == null) {
            state = null;
          }
          return this.attr("show", state);
        };

        MRTClassShowStimulus.prototype.exists = function() {
          return this.element != null;
        };

        return MRTClassShowStimulus;

      })(MRTClass);

      MRTClassShow.prototype.CompoundStimulus = function(elements, options) {
        if (options == null) {
          options = {};
        }
        return new this.MRTClassShowCompoundStimulus(this.root, elements, options);
      };

      MRTClassShow.prototype.MRTClassShowCompoundStimulus = MRTClassShowCompoundStimulus = (function(_super1) {
        __extends(MRTClassShowCompoundStimulus, _super1);

        MRTClassShowCompoundStimulus.prototype._defaultElement = 0;

        MRTClassShowCompoundStimulus.prototype._background = null;

        MRTClassShowCompoundStimulus.prototype._backgroundOffset = 0;

        function MRTClassShowCompoundStimulus(root, elements, options) {
          var _ref, _ref1;
          options.background = (_ref = options.background) != null ? _ref : null;
          this._backgroundOffset = (_ref1 = options.background_offset) != null ? _ref1 : 1;
          this.element = copy((elements instanceof MRTClassShowCompoundStimulus ? elements.element : elements));
          if (options.background != null) {
            if (options.background === true) {
              options.background = root.background;
            }
            this._background = root.show.Rectangle({
              color: options.background
            });
          }
          MRTClassShowCompoundStimulus.__super__.constructor.call(this, root, options, false);
          if (options.background != null) {
            if (this.element.length > 0) {
              this._background.element.insertBefore(this.element[0].element);
            }
            this.updateBackground(['width', 'height', 'x', 'y', 'show', 'mousedown', 'mouseup', 'mouseover', 'mouseout']);
          }
        }

        MRTClassShowCompoundStimulus.prototype.attr = function(name, value) {
          var el, fSize, ffEvent, i, n, pAll, pCur, pHigh, pLow, pMid, pMove, ret, sAll, sCur, xy, _i, _j, _k, _l, _len, _len1, _len2, _m, _ref, _ref1, _ref2, _ref3, _ref4;
          switch (name) {
            case "width":
            case "height":
              xy = this.type2xy(name);
              n = this.element.length;
              if (n === 0) {
                sCur = 0;
                pMid = 0;
              } else {
                sAll = (function() {
                  var _i, _len, _ref, _results;
                  _ref = this.element;
                  _results = [];
                  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    el = _ref[_i];
                    _results.push(el.attr(name));
                  }
                  return _results;
                }).call(this);
                pAll = (function() {
                  var _i, _len, _ref, _results;
                  _ref = this.element;
                  _results = [];
                  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    el = _ref[_i];
                    _results.push(el.attr(xy));
                  }
                  return _results;
                }).call(this);
                pLow = Math.min.apply(Math, (function() {
                  var _i, _ref, _results;
                  _results = [];
                  for (i = _i = 0, _ref = n - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
                    _results.push(pAll[i] - sAll[i] / 2);
                  }
                  return _results;
                })());
                pHigh = Math.max.apply(Math, (function() {
                  var _i, _ref, _results;
                  _results = [];
                  for (i = _i = 0, _ref = n - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
                    _results.push(pAll[i] + sAll[i] / 2);
                  }
                  return _results;
                })());
                pMid = (pLow + pHigh) / 2;
                sCur = pHigh - pLow;
              }
              if (value != null) {
                fSize = value / sCur;
                if (n > 0) {
                  for (i = _i = 0, _ref = n - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
                    this.element[i].attr(name, fSize * sAll[i]);
                  }
                  for (i = _j = 0, _ref1 = n - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
                    this.element[i].attr(xy, fSize * (pAll[i] - pMid) + pMid);
                  }
                  this.updateBackground([name, xy]);
                }
              } else {
                ret = sCur;
              }
              break;
            case "l":
            case "t":
              n = this.element.length;
              if (n === 0) {
                ret = pCur = (function() {
                  switch (name) {
                    case "l":
                      return this.root.width() / 2;
                    case "t":
                      return this.root.height() / 2;
                    default:
                      throw 'wtf?';
                  }
                }).call(this);
              } else {
                ret = pCur = Math.min.apply(Math, (function() {
                  var _k, _len, _ref2, _results;
                  _ref2 = this.element;
                  _results = [];
                  for (_k = 0, _len = _ref2.length; _k < _len; _k++) {
                    el = _ref2[_k];
                    _results.push(el.attr(name));
                  }
                  return _results;
                }).call(this));
              }
              if (value != null) {
                pMove = value - pCur;
                if (n > 0) {
                  _ref2 = this.element;
                  for (_k = 0, _len = _ref2.length; _k < _len; _k++) {
                    el = _ref2[_k];
                    el.attr(name, el.attr(name) + pMove);
                  }
                  this.updateBackground(name);
                }
              }
              break;
            case "cl":
            case "ct":
              ret = this.attr("" + name[1] + "c", value);
              break;
            case "box":
            case "x":
            case "y":
            case "cx":
            case "cy":
            case "lc":
            case "tc":
              ret = MRTClassShowCompoundStimulus.__super__.attr.call(this, name, value);
              if (value != null) {
                this.updateBackground(name);
              }
              break;
            case "element_mousedown":
              ffEvent = function(elm) {
                return function(e, x, y) {
                  return value(elm, x, y);
                };
              };
              _ref3 = this.element;
              for (_l = 0, _len1 = _ref3.length; _l < _len1; _l++) {
                el = _ref3[_l];
                el.attr("mousedown", ffEvent(el));
              }
              if (this._background != null) {
                this._background.attr("mousedown", ffEvent(this._background));
              }
              break;
            default:
              if (value != null) {
                _ref4 = this.element;
                for (_m = 0, _len2 = _ref4.length; _m < _len2; _m++) {
                  el = _ref4[_m];
                  el.attr(name, value);
                }
                switch (name) {
                  case 'show':
                  case 'mousedown':
                  case 'mouseup':
                  case 'mouseover':
                  case 'mouseout':
                    this.updateBackground(name);
                    break;
                  default:
                    null;
                }
              } else {
                ret = this.element.length > 0 ? this.element[this._defaultElement].attr(name) : null;
              }
          }
          if (value != null) {
            return this;
          } else {
            return ret;
          }
        };

        MRTClassShowCompoundStimulus.prototype._settransform = function() {
          var el, _i, _len, _ref, _results;
          _ref = this.element;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            el = _ref[_i];
            _results.push(el._settransform());
          }
          return _results;
        };

        MRTClassShowCompoundStimulus.prototype.rotate = function(a, xc, yc) {
          var el, _i, _len, _ref, _results;
          if (xc == null) {
            xc = null;
          }
          if (yc == null) {
            yc = null;
          }
          xc = xc != null ? xc : this.attr('x');
          yc = yc != null ? yc : this.attr('y');
          this._rotation = (this._rotation + a) % 360;
          _ref = this.element;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            el = _ref[_i];
            _results.push(el.rotate(a, xc, yc));
          }
          return _results;
        };

        MRTClassShowCompoundStimulus.prototype.scale = function(s, xc, yc) {
          var el, _i, _len, _ref, _results;
          if (xc == null) {
            xc = null;
          }
          if (yc == null) {
            yc = null;
          }
          xc = xc != null ? xc : this.attr('x');
          yc = yc != null ? yc : this.attr('y');
          this._scale = s * this._scale;
          _ref = this.element;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            el = _ref[_i];
            _results.push(el.scale(s, xc, yc));
          }
          return _results;
        };

        MRTClassShowCompoundStimulus.prototype.remove = function(el, removeElement) {
          var idx, _i, _len, _ref;
          if (el == null) {
            el = null;
          }
          if (removeElement == null) {
            removeElement = true;
          }
          if (el != null) {
            if (!(el instanceof MRTClassShowStimulus)) {
              idx = el;
            } else {
              idx = find(this.element, el)[0];
            }
            if (removeElement) {
              this.element[idx].remove();
            }
            this.element.splice(idx, 1);
          } else {
            if (removeElement) {
              _ref = this.element;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                el = _ref[_i];
                el.remove();
              }
            }
            this.element = [];
          }
          if (this._background != null) {
            return this._background.remove();
          }
        };

        MRTClassShowCompoundStimulus.prototype.exists = function() {
          return this.element.length > 0;
        };

        MRTClassShowCompoundStimulus.prototype.addElement = function(el) {
          this.element.push(el);
          if (!this._show_state) {
            return el.show(false);
          }
        };

        MRTClassShowCompoundStimulus.prototype.removeElement = function(el) {
          var idx;
          idx = this.getElementIndex(el);
          this.element[idx].remove();
          return this.element.splice(idx, 1);
        };

        MRTClassShowCompoundStimulus.prototype.getElement = function(el) {
          if (el instanceof MRTClassShowStimulus) {
            return el;
          } else {
            return this.element[el];
          }
        };

        MRTClassShowCompoundStimulus.prototype.getElementIndex = function(el) {
          if (!(el instanceof MRTClassShowStimulus)) {
            return el;
          } else {
            return find(this.element, el)[0];
          }
        };

        MRTClassShowCompoundStimulus.prototype.updateBackground = function(param) {
          var p, _i, _len, _ref, _results;
          if (this._background != null) {
            _ref = forceArray(param);
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              p = _ref[_i];
              switch (p) {
                case 'width':
                case 'height':
                  _results.push(this._background.attr(p, Math.max(0, this.attr(p) - 2 * this._backgroundOffset)));
                  break;
                case 'box':
                  _results.push(this.updateBackground(['width', 'height']));
                  break;
                case 'l':
                case 't':
                  _results.push(this._background.attr(p, this.attr(p) + this._backgroundOffset));
                  break;
                default:
                  _results.push(this._background.attr(p, this.attr(p)));
              }
            }
            return _results;
          }
        };

        return MRTClassShowCompoundStimulus;

      })(MRTClassShowStimulus);

      MRTClassShow.prototype.StimulusGrid = function(elements, options) {
        if (options == null) {
          options = {};
        }
        return new MRTClassShowStimulusGrid(this.root, elements, options);
      };

      MRTClassShow.prototype.MRTClassShowStimulusGrid = MRTClassShowStimulusGrid = (function(_super1) {
        __extends(MRTClassShowStimulusGrid, _super1);

        MRTClassShowStimulusGrid.prototype.padding = null;

        MRTClassShowStimulusGrid.prototype._attr = null;

        function MRTClassShowStimulusGrid(root, elements, options) {
          var _ref, _ref1, _ref2;
          options.width = (_ref = options.width) != null ? _ref : root.width();
          options.height = (_ref1 = options.height) != null ? _ref1 : root.height();
          this.padding = (_ref2 = options.padding) != null ? _ref2 : 8;
          this._attr = {
            width: options.width,
            height: options.height
          };
          MRTClassShowStimulusGrid.__super__.constructor.call(this, root, elements, options);
        }

        MRTClassShowStimulusGrid.prototype.attr = function(name, value) {
          var ret;
          switch (name) {
            case 'width':
            case 'height':
              if (value != null) {
                this._attr[name] = value;
                this.updatePositions();
              } else {
                ret = this._attr[name];
              }
              break;
            default:
              MRTClassShowStimulusGrid.__super__.attr.call(this, name, value);
          }
          if (value != null) {
            return this;
          } else {
            return ret;
          }
        };

        MRTClassShowStimulusGrid.prototype.addElement = function(el) {
          MRTClassShowStimulusGrid.__super__.addElement.call(this, el);
          return this.updatePositions();
        };

        MRTClassShowStimulusGrid.prototype.removeElement = function(el) {
          MRTClassShowStimulusGrid.__super__.removeElement.call(this, el);
          return this.updatePositions();
        };

        MRTClassShowStimulusGrid.prototype.updatePositions = function(w, h) {
          var c, cols, hFinal, hMax, hPer, idx, n, r, rows, wFinal, wMax, wPer, x, y, _i, _ref, _ref1, _results;
          if (w == null) {
            w = null;
          }
          if (h == null) {
            h = null;
          }
          n = this.element.length;
          _ref = squareGrid(n), rows = _ref[0], cols = _ref[1];
          w = w != null ? w : this.attr('width');
          h = h != null ? h : this.attr('height');
          wMax = w - (cols - 1) * this.padding;
          hMax = h - (rows - 1) * this.padding;
          wPer = wMax / cols;
          hPer = hMax / rows;
          wFinal = wPer * cols + this.padding * (cols - 1);
          hFinal = hPer * rows + this.padding * (rows - 1);
          _results = [];
          for (r = _i = 0, _ref1 = rows - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; r = 0 <= _ref1 ? ++_i : --_i) {
            _results.push((function() {
              var _j, _ref2, _results1;
              _results1 = [];
              for (c = _j = 0, _ref2 = cols - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; c = 0 <= _ref2 ? ++_j : --_j) {
                idx = cols * r + c;
                if (idx < n) {
                  x = -(wFinal - wPer) / 2 + c * (wPer + this.padding);
                  y = -(hFinal - hPer) / 2 + r * (hPer + this.padding);
                  this.element[idx].attr('box', [wPer, hPer]);
                  this.element[idx].attr('x', x);
                  _results1.push(this.element[idx].attr('y', y));
                } else {
                  _results1.push(void 0);
                }
              }
              return _results1;
            }).call(this));
          }
          return _results;
        };

        return MRTClassShowStimulusGrid;

      })(MRTClassShowCompoundStimulus);

      MRTClassShow.prototype.Choice = function(elements, options) {
        if (options == null) {
          options = {};
        }
        return new MRTClassShowChoice(this.root, elements, options);
      };

      MRTClassShow.prototype.MRTClassShowChoice = MRTClassShowChoice = (function(_super1) {
        __extends(MRTClassShowChoice, _super1);

        MRTClassShowChoice.prototype.choiceMade = false;

        MRTClassShowChoice.prototype.choice = null;

        MRTClassShowChoice.prototype.callback = null;

        MRTClassShowChoice.prototype.callback_delay = null;

        MRTClassShowChoice.prototype.timeout = null;

        MRTClassShowChoice.prototype._tStart = 0;

        MRTClassShowChoice.prototype._tChoice = 0;

        MRTClassShowChoice.prototype._choiceInclude = null;

        MRTClassShowChoice.prototype._instruction = null;

        MRTClassShowChoice.prototype._padx = null;

        MRTClassShowChoice.prototype._pady = null;

        MRTClassShowChoice.prototype._autoposition = false;

        MRTClassShowChoice.prototype._autosize = false;

        MRTClassShowChoice.prototype._choiceLocation = null;

        function MRTClassShowChoice(root, elements, options) {

          /*
            elements: an array of Stimulus objects
            options:
              instruct: the instruction to give
              autoposition: true to autoposition the elements
              autosize: true to autosize the choices
              choice_location: location of the choices (for autoposition). either
                               'middle' or 'bottom'
              choice_include: an array of indices of Stimulus objects to include
                              as choices
              callback: a function that takes this object and the chosen index as
                        inputs
              callback_delay: the delay, in milliseconds, before calling the
                              callback
              timeout: number of milliseconds before the choice times out
              pad: the padding in between each choice as a percentage of the total
                   canvas size
              padx: pad specifically for horizontal padding
              pady: pad specifically for vertical padding
           */
          var fDown, idx, _i, _j, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _results;
          MRTClassShowChoice.__super__.constructor.call(this, root, elements, options);
          options.instruct = (_ref = options.instruct) != null ? _ref : "Choose one.";
          this._autoposition = (_ref1 = options.autoposition) != null ? _ref1 : true;
          this._autosize = (_ref2 = options.autosize) != null ? _ref2 : true;
          this._choiceLocation = (_ref3 = options.choice_location) != null ? _ref3 : 'middle';
          options.pad = (_ref4 = options.pad) != null ? _ref4 : null;
          this._padx = (_ref5 = options.padx) != null ? _ref5 : (_ref6 = options.pad) != null ? _ref6 : 5;
          this._pady = (_ref7 = options.pady) != null ? _ref7 : (_ref8 = options.pad) != null ? _ref8 : 10;
          this.callback = (_ref9 = options.callback) != null ? _ref9 : null;
          this.callback_delay = (_ref10 = options.callback_delay) != null ? _ref10 : 0;
          this.timeout = (_ref11 = options.timeout) != null ? _ref11 : null;
          options.choice_include = (_ref12 = options.choice_include) != null ? _ref12 : (function() {
            _results = [];
            for (var _i = 0, _ref13 = this.element.length - 1; 0 <= _ref13 ? _i <= _ref13 : _i >= _ref13; 0 <= _ref13 ? _i++ : _i--){ _results.push(_i); }
            return _results;
          }).apply(this);
          this._choiceInclude = (function() {
            var _j, _len, _ref14, _results1;
            _ref14 = options.choice_include;
            _results1 = [];
            for (_j = 0, _len = _ref14.length; _j < _len; _j++) {
              idx = _ref14[_j];
              _results1.push(this.element[idx]);
            }
            return _results1;
          }).call(this);
          for (idx = _j = 0, _ref14 = this._choiceInclude.length - 1; 0 <= _ref14 ? _j <= _ref14 : _j >= _ref14; idx = 0 <= _ref14 ? ++_j : --_j) {
            fDown = ((function(_this) {
              return function(i) {
                return function(e, x, y) {
                  return _this.choiceEvent(i);
                };
              };
            })(this))(idx);
            this._choiceInclude[idx].mousedown(fDown);
          }
          if (options.instruct !== false) {
            this._instruction = root.show.Instructions(options.instruct);
            this.element.push(this._instruction);
          }
          this.autoPosition();
          this._tStart = this.root.time.Now();
          if (this.timeout != null) {
            window.setTimeout(((function(_this) {
              return function() {
                return _this.choiceEvent(null);
              };
            })(this)), this.timeout);
          }
        }

        MRTClassShowChoice.prototype.autoPosition = function() {
          var el, elH, elW, hFinalMax, hInstruct, hMax, hScale, hTotal, idx, nEl, padHPx, padWPx, scale, wFinalMax, wMax, wScale, wTotal, xCur, yChoice, yInstruct, _i, _j, _len, _len1, _ref, _ref1;
          hInstruct = this._instruction != null ? this._instruction.attr("height") : 0;
          nEl = this._choiceInclude.length;
          wTotal = this.root.width();
          hTotal = this.root.height();
          padWPx = wTotal * this._padx / 100;
          padHPx = hTotal * this._pady / 100;
          wFinalMax = Math.max(10, (wTotal - (nEl + 1) * padWPx) / nEl);
          hFinalMax = Math.max(10, 2 * (hTotal / 2 - hInstruct - padHPx));
          elW = (function() {
            var _i, _len, _ref, _results;
            _ref = this._choiceInclude;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              el = _ref[_i];
              _results.push(el.attr("width"));
            }
            return _results;
          }).call(this);
          elH = (function() {
            var _i, _len, _ref, _results;
            _ref = this._choiceInclude;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              el = _ref[_i];
              _results.push(el.attr("height"));
            }
            return _results;
          }).call(this);
          wMax = Math.max.apply(Math, elW);
          hMax = Math.max.apply(Math, elH);
          if (this._autosize) {
            wScale = wFinalMax / wMax;
            hScale = hFinalMax / hMax;
            scale = Math.min(wScale, hScale);
            _ref = this._choiceInclude;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              el = _ref[_i];
              el.attr("box", [scale * el.attr("width"), scale * el.attr("height")]);
            }
            elW = (function() {
              var _j, _len1, _ref1, _results;
              _ref1 = this._choiceInclude;
              _results = [];
              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                el = _ref1[_j];
                _results.push(el.attr("width"));
              }
              return _results;
            }).call(this);
            elH = (function() {
              var _j, _len1, _ref1, _results;
              _ref1 = this._choiceInclude;
              _results = [];
              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                el = _ref1[_j];
                _results.push(el.attr("height"));
              }
              return _results;
            }).call(this);
            wMax = Math.max.apply(Math, elW);
            hMax = Math.max.apply(Math, elH);
          }
          if (this._autoposition) {
            yChoice = (function() {
              switch (this._choiceLocation) {
                case 'middle':
                  return 0;
                case 'bottom':
                  return (hTotal - hMax) / 2 - padHPx;
                default:
                  throw 'Invalid choice location';
              }
            }).call(this);
            wTotal = sum(elW) + padWPx * (nEl - 1) - elW[0] / 2 - elW.slice(-1) / 2;
            xCur = -wTotal / 2;
            _ref1 = this._choiceInclude;
            for (idx = _j = 0, _len1 = _ref1.length; _j < _len1; idx = ++_j) {
              el = _ref1[idx];
              el.attr("x", xCur);
              el.attr("y", yChoice);
              xCur += elW[idx] + padWPx;
            }
          }
          if (this._instruction != null) {
            yInstruct = (function() {
              switch (this._choiceLocation) {
                case 'middle':
                  return hMax / 2 + padHPx;
                case 'bottom':
                  return 0;
                default:
                  throw 'Invalid choice location';
              }
            }).call(this);
            return this._instruction.attr("y", yInstruct);
          }
        };

        MRTClassShowChoice.prototype.choiceEvent = function(idx) {
          if (!this.choiceMade) {
            this._tChoice = this.root.time.Now();
            this.choiceMade = true;
            this.choice = idx;
            if (this.callback != null) {
              return window.setTimeout(((function(_this) {
                return function() {
                  return _this.callback(_this, idx);
                };
              })(this)), this.callback_delay);
            }
          }
        };

        return MRTClassShowChoice;

      })(MRTClassShowCompoundStimulus);

      MRTClassShow.prototype.Test = function(elements, options) {
        if (options == null) {
          options = {};
        }
        return new MRTClassShowTest(this.root, elements, options);
      };

      MRTClassShow.prototype.MRTClassShowTest = MRTClassShowTest = (function(_super1) {
        __extends(MRTClassShowTest, _super1);

        MRTClassShowTest.prototype.correct = null;

        function MRTClassShowTest(root, elements, options) {
          var el, idx, _i, _j, _len, _len1, _ref, _ref1, _ref2;
          if (options == null) {
            options = {};
          }

          /*
            elements: an array of Stimulus objects
            options:
              correct: the index of the correct choice / array of indices. if this
                       is unspecified, then each Stimulus object should have a
                       boolean property named "correct" the specifies whether the
                       Stimulus is a correct choice.
           */
          this.root = root;
          options.correct = forceArray((_ref = options.correct) != null ? _ref : null);
          MRTClassShowTest.__super__.constructor.call(this, root, elements, options);
          if (options.correct != null) {
            _ref1 = this.element;
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              el = _ref1[_i];
              el.correct = false;
            }
            _ref2 = options.correct;
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              idx = _ref2[_j];
              this.element[idx].correct = true;
            }
          }
        }

        MRTClassShowTest.prototype.choiceEvent = function(idx) {
          this.correct = idx != null ? this.element[idx].correct : false;
          return MRTClassShowTest.__super__.choiceEvent.call(this, idx);
        };

        return MRTClassShowTest;

      })(MRTClassShowChoice);

      MRTClassShow.prototype.Dialog = function(prompt, choices, options) {
        if (options == null) {
          options = {};
        }
        return new MRTClassShowDialog(this.root, prompt, choices, options);
      };

      MRTClassShow.prototype.MRTClassShowDialog = MRTClassShowDialog = (function(_super1) {
        __extends(MRTClassShowDialog, _super1);

        MRTClassShowDialog.prototype._userCallback = null;

        function MRTClassShowDialog(root, prompt, choices, options) {
          var ch, choice, _i, _len, _ref, _ref1, _ref2;
          options.autosize = (_ref = options.autosize) != null ? _ref : false;
          options['font-size'] = (_ref1 = options['font-size']) != null ? _ref1 : 48;
          choice = [];
          for (_i = 0, _len = choices.length; _i < _len; _i++) {
            ch = choices[_i];
            choice.push(root.show.Link('javascript:void(0)', ch, {
              'font-size': options['font-size']
            }));
          }
          options.instruct = prompt;
          options.choice_location = (_ref2 = options.choice_location) != null ? _ref2 : 'bottom';
          this._userCallback = options.callback;
          options.callback = (function(_this) {
            return function(choice, idx) {
              choice.remove();
              if (_this._userCallback != null) {
                return _this.runUserCallback(idx);
              }
            };
          })(this);
          MRTClassShowDialog.__super__.constructor.call(this, root, choice, options);
        }

        MRTClassShowDialog.prototype.runUserCallback = function(idx) {
          return this._userCallback(idx);
        };

        return MRTClassShowDialog;

      })(MRTClassShowChoice);

      MRTClassShow.prototype.YesNo = function(prompt, options) {
        if (options == null) {
          options = {};
        }
        return new MRTClassShowYesNo(this.root, prompt, options);
      };

      MRTClassShow.prototype.MRTClassShowYesNo = MRTClassShowYesNo = (function(_super1) {
        __extends(MRTClassShowYesNo, _super1);

        function MRTClassShowYesNo(root, prompt, options) {
          MRTClassShowYesNo.__super__.constructor.call(this, root, prompt, ['YES', 'NO'], options);
        }

        MRTClassShowYesNo.prototype.runUserCallback = function(idx) {
          return this._userCallback(idx === 0);
        };

        return MRTClassShowYesNo;

      })(MRTClassShowDialog);

      MRTClassShow.prototype.Ok = function(prompt, options) {
        if (options == null) {
          options = {};
        }
        return new MRTClassShowOk(this.root, prompt, options);
      };

      MRTClassShow.prototype.MRTClassShowOk = MRTClassShowOk = (function(_super1) {
        __extends(MRTClassShowOk, _super1);

        function MRTClassShowOk(root, prompt, options) {
          MRTClassShowOk.__super__.constructor.call(this, root, prompt, ['OK'], options);
        }

        MRTClassShowOk.prototype.runUserCallback = function(idx) {
          return this._userCallback();
        };

        return MRTClassShowOk;

      })(MRTClassShowDialog);

      MRTClassShow.prototype.Rectangle = function(options) {
        if (options == null) {
          options = {};
        }
        return new MRTClassShowRectangle(this.root, options);
      };

      MRTClassShow.prototype.MRTClassShowRectangle = MRTClassShowRectangle = (function(_super1) {
        __extends(MRTClassShowRectangle, _super1);

        function MRTClassShowRectangle(root, options) {
          var h, l, t, w, _ref;
          this.root = root;
          options = this.parseOptions(options);
          options.stroke = (_ref = options.stroke) != null ? _ref : "none";
          l = this.x2l(options.x, options.width);
          t = this.y2t(options.y, options.height);
          w = options.width;
          h = options.height;
          this.element = root.paper.rect(l, t, w, h);
          options = remove(options, ['width', 'height', 'x', 'y']);
          MRTClassShowRectangle.__super__.constructor.call(this, root, options, false);
        }

        return MRTClassShowRectangle;

      })(MRTClassShowStimulus);

      MRTClassShow.prototype.Square = function(options) {
        if (options == null) {
          options = {};
        }
        return new MRTClassShowSquare(this.root, options);
      };

      MRTClassShow.prototype.MRTClassShowSquare = MRTClassShowSquare = (function(_super1) {
        __extends(MRTClassShowSquare, _super1);

        function MRTClassShowSquare(root, options) {
          this.root = root;
          if (options.width != null) {
            options.height = options.width;
          }
          if (options.height != null) {
            options.width = options.height;
          }
          options = this.parseOptions(options);
          MRTClassShowSquare.__super__.constructor.call(this, root, options);
        }

        MRTClassShowSquare.prototype.attr = function(name, value) {
          switch (name) {
            case "length":
            case "width":
            case "height":
              MRTClassShowSquare.__super__.attr.call(this, "width", value);
              return MRTClassShowSquare.__super__.attr.call(this, "height", value);
            default:
              return MRTClassShowSquare.__super__.attr.call(this, name, value);
          }
        };

        return MRTClassShowSquare;

      })(MRTClassShowRectangle);

      MRTClassShow.prototype.Circle = function(options) {
        if (options == null) {
          options = {};
        }
        return new MRTClassShowCircle(this.root, options);
      };

      MRTClassShow.prototype.MRTClassShowCircle = MRTClassShowCircle = (function(_super1) {
        __extends(MRTClassShowCircle, _super1);

        function MRTClassShowCircle(root, options) {
          var cl, ct, r;
          this.root = root;
          options = this.parseOptions(options, {
            r: this._defaults.width / 2
          });
          cl = this.x2l(options.x, 2 * options.r) + options.r;
          ct = this.y2t(options.y, 2 * options.r) + options.r;
          r = options.r;
          this.element = root.paper.circle(cl, ct, r);
          options = remove(options, ['x', 'y', 'r', 'width', 'height']);
          MRTClassShowCircle.__super__.constructor.call(this, root, options, false);
          this.element.attr("stroke", "none");
        }

        MRTClassShowCircle.prototype.attr = function(name, value) {
          var ret, wh, xy;
          switch (name) {
            case "width":
            case "height":
              if (value != null) {
                if (value === 'auto') {
                  return MRTClassShowCircle.__super__.attr.call(this, name, value);
                } else {
                  return MRTClassShowCircle.__super__.attr.call(this, "r", value / 2);
                }
              } else {
                return 2 * MRTClassShowCircle.__super__.attr.call(this, "r");
              }
              break;
            case "l":
            case "t":
              xy = "c" + (this.type2xy(name));
              wh = this.type2wh(name);
              if (value != null) {
                return this.element.attr(xy, value + this.attr(wh) / 2);
              } else {
                return ret = this.element.attr(xy) - this.attr(wh) / 2;
              }
              break;
            default:
              return MRTClassShowCircle.__super__.attr.call(this, name, value);
          }
        };

        return MRTClassShowCircle;

      })(MRTClassShowStimulus);

      MRTClassShow.prototype.Text = function(text, options) {
        if (options == null) {
          options = {};
        }
        return new MRTClassShowText(this.root, text, options);
      };

      MRTClassShow.prototype.MRTClassShowText = MRTClassShowText = (function(_super1) {
        __extends(MRTClassShowText, _super1);

        MRTClassShowText.prototype._max_width = 0;

        MRTClassShowText.prototype._max_height = 0;

        function MRTClassShowText(root, text, options) {
          this.root = root;
          this.element = root.paper.text(0, 0, text);
          options = this.parseOptions(options, {
            "font-family": "Arial",
            "font-size": 18,
            "text-anchor": "middle",
            "max-width": root.width(),
            "max-height": root.height()
          });
          options = remove(options, ['width', 'height']);
          MRTClassShowText.__super__.constructor.call(this, root, options, false);
        }

        MRTClassShowText.prototype.attr = function(name, value) {
          var f, fontSize, fontSizeNew, ret, sCur, tActual, ta, x, y;
          switch (name) {
            case "l":
              ta = this.attr("text-anchor");
              switch (ta) {
                case "middle":
                  if (value != null) {
                    MRTClassShowText.__super__.attr.call(this, name, value + this.attr('width') / 2);
                  } else {
                    ret = MRTClassShowText.__super__.attr.call(this, name) - this.attr('width') / 2;
                  }
                  break;
                default:
                  ret = MRTClassShowText.__super__.attr.call(this, name, value);
              }
              break;
            case "t":
              if (value != null) {
                tActual = Math.min(this.root.height() - this.attr("height") / 2, value + this.attr("height") / 2);
                MRTClassShowText.__super__.attr.call(this, name, tActual);
              } else {
                ret = MRTClassShowText.__super__.attr.call(this, name) - this.attr("height") / 2;
              }
              break;
            case "width":
            case "height":
              if (value != null) {
                if (value === 'auto') {
                  MRTClassShowText.__super__.attr.call(this, name, value);
                } else {
                  sCur = this.attr(name);
                  f = value / sCur;
                  fontSize = this.attr('font-size');
                  fontSizeNew = f * fontSize;
                  this.attr("font-size", fontSizeNew);
                }
              } else {
                ret = this.element.getBBox()[name];
              }
              break;
            case "font-size":
              if (value != null) {
                x = this.attr("x");
                y = this.attr("y");
                MRTClassShowText.__super__.attr.call(this, name, value);
                this.attr("x", x);
                this.attr("y", y);
              } else {
                ret = MRTClassShowText.__super__.attr.call(this, name);
              }
              break;
            case "max-width":
              if (value != null) {
                this._max_width = value;
                if (this.attr("width") > this._max_width) {
                  this.attr("width", this._max_width);
                }
              } else {
                ret = this._max_width;
              }
              break;
            case "max-height":
              if (value != null) {
                this._max_height = value;
                if (this.attr("height") > this._max_height) {
                  this.attr("height", this._max_height);
                }
              } else {
                ret = this._max_height;
              }
              break;
            default:
              ret = MRTClassShowText.__super__.attr.call(this, name, value);
          }
          if (value != null) {
            return this;
          } else {
            return ret;
          }
        };

        return MRTClassShowText;

      })(MRTClassShowStimulus);

      MRTClassShow.prototype.Instructions = function(text, options) {
        if (options == null) {
          options = {};
        }
        return new MRTClassShowInstructions(this.root, text, options);
      };

      MRTClassShow.prototype.MRTClassShowInstructions = MRTClassShowInstructions = (function(_super1) {
        __extends(MRTClassShowInstructions, _super1);

        function MRTClassShowInstructions(root, text, options) {
          this.root = root;
          options = this.parseOptions(options, {
            "font-family": "Arial",
            "text-anchor": 'middle',
            "font-size": 36
          });
          MRTClassShowInstructions.__super__.constructor.call(this, root, text, options);
        }

        return MRTClassShowInstructions;

      })(MRTClassShowText);

      MRTClassShow.prototype.Link = function(url, text, options) {
        if (options == null) {
          options = {};
        }
        return new MRTClassShowLink(this.root, url, text, options);
      };

      MRTClassShow.prototype.MRTClassShowLink = MRTClassShowLink = (function(_super1) {
        __extends(MRTClassShowLink, _super1);

        MRTClassShowLink.prototype.color = null;

        MRTClassShowLink.prototype.colorHover = null;

        function MRTClassShowLink(root, url, text, options) {
          var _ref, _ref1;
          options.href = url;
          this.color = options.color = (_ref = options.color) != null ? _ref : 'blue';
          this.colorHover = (_ref1 = options.color_hover) != null ? _ref1 : 'deepskyblue';
          options.mouseover = (function(_this) {
            return function() {
              return _this.attr('color', _this.colorHover);
            };
          })(this);
          options.mouseout = (function(_this) {
            return function() {
              return _this.attr('color', _this.color);
            };
          })(this);
          MRTClassShowLink.__super__.constructor.call(this, root, text, options);
        }

        return MRTClassShowLink;

      })(MRTClassShowText);

      MRTClassShow.prototype.Timer = function(tTotal, options) {
        if (options == null) {
          options = {};
        }
        return new MRTClassShowTimer(this.root, tTotal, options);
      };

      MRTClassShow.prototype.MRTClassShowTimer = MRTClassShowTimer = (function(_super1) {
        __extends(MRTClassShowTimer, _super1);

        MRTClassShowTimer.prototype.tTotal = 0;

        MRTClassShowTimer.prototype.tTimer = null;

        MRTClassShowTimer.prototype.tGo = null;

        MRTClassShowTimer.prototype.name = null;

        MRTClassShowTimer.prototype.showms = false;

        MRTClassShowTimer.prototype.prefix = null;

        MRTClassShowTimer.prototype.suffix = null;

        MRTClassShowTimer.prototype._timeout = null;

        MRTClassShowTimer.prototype._initialized = false;

        MRTClassShowTimer.prototype._intervalID = null;

        MRTClassShowTimer.prototype._setTimer = function(t) {
          this.tTimer.set(t);
          return this.render();
        };

        function MRTClassShowTimer(root, tTotal, options) {
          var _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
          options.initialize = (_ref = options.initialize) != null ? _ref : true;
          this.tTotal = tTotal;
          this.name = (_ref1 = options.name) != null ? _ref1 : 'timer';
          this.showms = (_ref2 = options.showms) != null ? _ref2 : false;
          this.prefix = (_ref3 = options.prefix) != null ? _ref3 : null;
          this.suffix = (_ref4 = options.suffix) != null ? _ref4 : 'remaining';
          this.tUpdate = (_ref5 = options.update_interval) != null ? _ref5 : (this.showms ? 10 : 250);
          this._timeout = (_ref6 = options.timeout) != null ? _ref6 : null;
          MRTClassShowTimer.__super__.constructor.call(this, root, '', options);
          if (options.initialize) {
            this.initialize();
          }
        }

        MRTClassShowTimer.prototype.initialize = function() {
          if (!this._initialized) {
            this.tTimer = this.root.data.Variable("" + this.name + "_remaining", this.tTotal, {
              timeout: this._timeout,
              callback: (function(_this) {
                return function(t) {
                  return _this.render();
                };
              })(this)
            });
            this._initialized = true;
          }
          return this.render();
        };

        MRTClassShowTimer.prototype.remaining = function() {
          if (this._initialized) {
            return Math.max(0, this.tGo != null ? this.tTimer.get() - (this.root.time.Now() - this.tGo) : this.tTimer.get());
          } else {
            return 0;
          }
        };

        MRTClassShowTimer.prototype.nextReset = function() {
          return this.tTimer.nextReset();
        };

        MRTClassShowTimer.prototype.string = function() {
          var prefix, strTime, suffix;
          strTime = time2str(this.remaining(), this.showms);
          prefix = this.prefix != null ? "" + this.prefix + ": " : '';
          suffix = this.suffix != null ? " " + this.suffix : '';
          return "" + prefix + strTime + suffix;
        };

        MRTClassShowTimer.prototype.render = function() {
          return this.attr("text", this.string());
        };

        MRTClassShowTimer.prototype.update = function() {
          if (this.remaining() <= 0) {
            this.stop();
          }
          return this.render();
        };

        MRTClassShowTimer.prototype.go = function() {
          this.tGo = this.root.time.Now();
          return this._intervalID = window.setInterval(((function(_this) {
            return function() {
              return _this.update();
            };
          })(this)), this.tUpdate);
        };

        MRTClassShowTimer.prototype.stop = function() {
          var tRemain;
          if (this._intervalID != null) {
            clearInterval(this._intervalID);
          }
          tRemain = this.remaining();
          this.tGo = null;
          return this._setTimer(tRemain);
        };

        return MRTClassShowTimer;

      })(MRTClassShowText);

      MRTClassShow.prototype.ItemList = function(items, options) {
        if (items == null) {
          items = {};
        }
        if (options == null) {
          options = {};
        }
        return new MRTClassShowItemList(this.root, items, options);
      };

      MRTClassShow.prototype.MRTClassShowItemList = MRTClassShowItemList = (function(_super1) {
        __extends(MRTClassShowItemList, _super1);

        MRTClassShowItemList.prototype._items = null;

        function MRTClassShowItemList(root, items, options) {
          var _ref;
          options['font-size'] = (_ref = options['font-size']) != null ? _ref : 12;
          MRTClassShowItemList.__super__.constructor.call(this, root, '', options);
          this.set(items);
        }

        MRTClassShowItemList.prototype.set = function(items) {
          this._items = items;
          return this.render();
        };

        MRTClassShowItemList.prototype.add = function(key, content) {
          this._items[key] = content;
          return this.render();
        };

        MRTClassShowItemList.prototype.remove = function(key) {
          delete this._items[key];
          return this.render();
        };

        MRTClassShowItemList.prototype.render = function() {
          var content, key, t, val;
          content = (function() {
            var _ref, _results;
            _ref = this._items;
            _results = [];
            for (key in _ref) {
              val = _ref[key];
              _results.push(val);
            }
            return _results;
          }).call(this);
          t = this.attr('t');
          this.attr('text', content.join("\n"));
          return this.attr('t', t);
        };

        return MRTClassShowItemList;

      })(MRTClassShowText);

      MRTClassShow.prototype.Path = function(path, options) {
        if (options == null) {
          options = {};
        }
        return new MRTClassShowPath(this.root, path, options);
      };

      MRTClassShow.prototype.MRTClassShowPath = MRTClassShowPath = (function(_super1) {
        __extends(MRTClassShowPath, _super1);

        MRTClassShowPath.prototype._param = null;

        function MRTClassShowPath(root, path, options) {
          var bAuto, bHeightAuto, bWidthAuto, _ref, _ref1, _ref2;
          this.root = root;
          options.width = (_ref = options.width) != null ? _ref : 100;
          options.height = (_ref1 = options.height) != null ? _ref1 : 100;
          options['stroke-width'] = (_ref2 = options['stroke-width']) != null ? _ref2 : 0;
          bWidthAuto = options.width === 'auto';
          bHeightAuto = options.height === 'auto';
          bAuto = bWidthAuto || bHeightAuto;
          if (bWidthAuto) {
            if (!bHeightAuto) {
              options.width = options.height;
            } else {
              options.width = 100;
              options.height = 100;
            }
          } else if (bHeightAuto) {
            options.height = options.width;
          }
          this._param = {
            path: path,
            width: options.width,
            height: options.height,
            l: (root.width() - options.width) / 2,
            t: (root.height() - options.height) / 2,
            orientation: 0
          };
          this.element = root.paper.path(this.constructPath(null, false));
          options = remove(options, ['width', 'height']);
          MRTClassShowPath.__super__.constructor.call(this, root, options, false);
          if (bAuto) {
            this.attr('width', 'auto');
          }
        }

        MRTClassShowPath.prototype._bottomRightCorner = function() {
          var p;
          p = [this._param.width / 2, this._param.height / 2];
          return rotate(p, this._param.orientation);
        };

        MRTClassShowPath.prototype._topRightCorner = function() {
          var p;
          p = [this._param.width / 2, -this._param.height / 2];
          return rotate(p, this._param.orientation);
        };

        MRTClassShowPath.prototype._maxExtent = function(idx) {
          return 2 * Math.max(Math.abs(this._bottomRightCorner()[idx]), Math.abs(this._topRightCorner()[idx]));
        };

        MRTClassShowPath.prototype.rotatedWidth = function() {
          return this._maxExtent(0);
        };

        MRTClassShowPath.prototype.rotatedHeight = function() {
          return this._maxExtent(1);
        };

        MRTClassShowPath.prototype.attr = function(name, value) {
          var p, ret;
          switch (name) {
            case "path":
            case "width":
            case "height":
            case "l":
            case "t":
            case "orientation":
              if (value != null) {
                if (value === 'auto') {
                  MRTClassShowPath.__super__.attr.call(this, name, value);
                } else {
                  p = {};
                  p[name] = value;
                  if (name === 'width') {
                    p.l = this._param.l + (this._param.width - value) / 2;
                  } else if (name === 'height') {
                    p.t = this._param.t + (this._param.height - value) / 2;
                  }
                  this.constructPath(p);
                }
              } else {
                ret = this._param[name];
              }
              break;
            default:
              ret = MRTClassShowPath.__super__.attr.call(this, name, value);
          }
          if (value != null) {
            return this;
          } else {
            return ret;
          }
        };

        MRTClassShowPath.prototype.rotate = function(a, xc, yc) {
          var r, theta, xDiff, yDiff;
          if (xc == null) {
            xc = null;
          }
          if (yc == null) {
            yc = null;
          }
          if ((xc != null) || (yc != null)) {
            xc = xc != null ? xc : this.attr("x");
            yc = yc != null ? yc : this.attr("y");
            xDiff = (this.attr("x")) - xc;
            yDiff = (this.attr("y")) - yc;
            r = Math.sqrt(Math.pow(xDiff, 2) + Math.pow(yDiff, 2));
            theta = Math.atan2(yDiff, xDiff);
            theta += a * Math.PI / 180;
            this.attr("x", r * Math.cos(theta) + xc);
            this.attr("y", r * Math.sin(theta) + yc);
          }
          return this.attr("orientation", this.attr("orientation") + a);
        };

        MRTClassShowPath.prototype.constructPath = function(param, setPath) {
          var a, f, idx, offset, op, origin, p, path, s, v, _i, _j, _len, _ref, _ref1;
          if (param == null) {
            param = {};
          }
          if (setPath == null) {
            setPath = true;
          }
          for (p in param) {
            v = param[p];
            this._param[p] = v;
          }
          s = [this._param.width, this._param.height];
          offset = [this._param.l, this._param.t];
          a = this._param.orientation;
          origin = add(mult(rotate([0, 0], a, [0.5, 0.5]), s), offset);
          path = "M" + origin;
          _ref = this._param.path;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            op = _ref[_i];
            path += op[0];
            if (op.length > 1) {
              for (idx = _j = 1, _ref1 = op.length - 1; _j <= _ref1; idx = _j += 2) {
                f = rotate(op.slice(idx, +(idx + 1) + 1 || 9e9), a, [0.5, 0.5]);
                p = add(mult(f, s), offset);
                path += p + ",";
              }
            }
          }
          if (setPath) {
            return this.element.attr("path", path);
          } else {
            return path;
          }
        };

        return MRTClassShowPath;

      })(MRTClassShowStimulus);

      MRTClassShow.prototype.X = function(options) {
        if (options == null) {
          options = {};
        }
        return new MRTClassShowX(this.root, options);
      };

      MRTClassShow.prototype.MRTClassShowX = MRTClassShowX = (function(_super1) {
        __extends(MRTClassShowX, _super1);

        function MRTClassShowX(root, options) {
          var path, _ref, _ref1, _ref2;
          options.width = (_ref = options.width) != null ? _ref : 16;
          options.height = (_ref1 = options.height) != null ? _ref1 : 16;
          options['stroke-width'] = (_ref2 = options['stroke-width']) != null ? _ref2 : 4;
          path = [['M', 0, 0], ['L', 1, 1], ['M', 0, 1], ['L', 1, 0]];
          MRTClassShowX.__super__.constructor.call(this, root, path, options);
        }

        return MRTClassShowX;

      })(MRTClassShowPath);

      MRTClassShow.prototype.Image = function(src, options) {
        if (options == null) {
          options = {};
        }
        return new MRTClassShowImage(this.root, src, options);
      };

      MRTClassShow.prototype.MRTClassShowImage = MRTClassShowImage = (function(_super1) {
        __extends(MRTClassShowImage, _super1);

        function MRTClassShowImage(root, src, options) {
          var bAutoSize, h, l, t, w;
          this.root = root;
          bAutoSize = src in this.root.im;
          options = this.parseOptions(options, {
            width: bAutoSize ? this.root.im[src].width : this._defaults.width,
            height: bAutoSize ? this.root.im[src].height : this._defaults.height
          });
          l = this.x2l(options.x, options.width);
          t = this.y2t(options.y, options.height);
          w = options.width;
          h = options.height;
          this.element = this.root.paper.image(src, l, t, w, h);
          options = remove(options, ['x', 'y', 'width', 'height']);
          MRTClassShowImage.__super__.constructor.call(this, root, options, false);
        }

        MRTClassShowImage.prototype.attr = function(name, value) {
          switch (name) {
            case "color":
              return null;
            default:
              return MRTClassShowImage.__super__.attr.call(this, name, value);
          }
        };

        return MRTClassShowImage;

      })(MRTClassShowStimulus);

      MRTClassShow.prototype.ColorMask = function(src, options) {
        if (options == null) {
          options = {};
        }
        return new MRTClassShowColorMask(this.root, src, options);
      };

      MRTClassShow.prototype.MRTClassShowColorMask = MRTClassShowColorMask = (function(_super1) {
        __extends(MRTClassShowColorMask, _super1);

        MRTClassShowColorMask.prototype._im = null;

        function MRTClassShowColorMask(root, src, options) {
          var bAutoSize;
          this.root = root;
          bAutoSize = src in root.im;
          options = this.parseOptions(options, {
            width: bAutoSize ? root.im[src].width : this._defaults.width,
            height: bAutoSize ? root.im[src].height : this._defaults.height
          });
          if (options.color !== "none") {
            options.background = options.color;
          }
          options = remove(options, ['color']);
          this._im = root.show.Image(src);
          MRTClassShowColorMask.__super__.constructor.call(this, root, [this._im], options);
        }

        MRTClassShowColorMask.prototype.attr = function(name, value) {
          var ret;
          switch (name) {
            case "color":
              if (this._background != null) {
                ret = this._background.attr(name, value);
              }
              break;
            default:
              ret = MRTClassShowColorMask.__super__.attr.call(this, name, value);
          }
          if (value != null) {
            return this;
          } else {
            return ret;
          }
        };

        return MRTClassShowColorMask;

      })(MRTClassShowCompoundStimulus);

      MRTClassShow.prototype.Progress = function(info, options) {
        if (options == null) {
          options = {};
        }
        return new MRTClassShowProgress(this.root, info, options);
      };

      MRTClassShow.prototype.MRTClassShowProgress = MRTClassShowProgress = (function(_super1) {
        __extends(MRTClassShowProgress, _super1);

        MRTClassShowProgress.prototype._steps = 0;

        MRTClassShowProgress.prototype._width = 0;

        function MRTClassShowProgress(root, info, options) {
          var bit, elements, i, _i, _ref;
          this.root = root;
          options = this.parseOptions(options, {
            width: 300,
            steps: 10,
            color: "red",
            r: 5
          });
          this._steps = options.steps;
          this._width = options.width;
          elements = [root.show.Instructions(info)];
          for (i = _i = 0, _ref = this._steps - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
            bit = root.show.Circle({
              r: options.r
            });
            bit.show(false);
            elements.push(bit);
          }
          delete options.r;
          MRTClassShowProgress.__super__.constructor.call(this, root, elements, options);
        }

        MRTClassShowProgress.prototype.attr = function(name, value) {
          var bottom, colBase, k, ret, top, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
          switch (name) {
            case "steps":
              ret = this._steps;
              break;
            case "width":
              ret = Math.max(this._width, this.element[0].attr("width"));
              break;
            case "height":
              bottom = this.element[this._steps].attr("y") + this.element[this._steps].attr("height");
              top = this.element[0].attr("y") - this.element[0].attr("height") / 2;
              ret = bottom - top;
              break;
            case "x":
              if (value != null) {
                this.element[0].attr(name, value);
                for (k = _i = 1, _ref = this._steps; 1 <= _ref ? _i <= _ref : _i >= _ref; k = 1 <= _ref ? ++_i : --_i) {
                  this.element[k].attr(name, -this._width / 2 + (k - 1) * this._width / (this._steps - 1));
                }
              } else {
                ret = this.element[0].attr(name);
              }
              break;
            case "y":
              if (value != null) {
                this.element[0].attr(name, value - 32);
                for (k = _j = 1, _ref1 = this._steps; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; k = 1 <= _ref1 ? ++_j : --_j) {
                  this.element[k].attr(name, value);
                }
              } else {
                ret = this.element[this._steps].attr(name);
              }
              break;
            case "color":
              if (value != null) {
                colBase = Raphael.color(value);
                for (k = _k = 1, _ref2 = this._steps; 1 <= _ref2 ? _k <= _ref2 : _k >= _ref2; k = 1 <= _ref2 ? ++_k : --_k) {
                  this.element[k].attr("color", "rgba(" + colBase.r + "," + colBase.g + "," + colBase.b + "," + (k / this._steps) + ")");
                }
              } else {
                ret = this.element[this._steps].attr(name);
              }
              break;
            case "r":
              if (value != null) {
                for (k = _l = 1, _ref3 = this._steps; 1 <= _ref3 ? _l <= _ref3 : _l >= _ref3; k = 1 <= _ref3 ? ++_l : --_l) {
                  this.element[k].attr("r", value);
                }
              } else {
                ret = this.element[this._steps - 1].attr(name);
              }
              break;
            default:
              ret = MRTClassShowProgress.__super__.attr.call(this, name, value);
          }
          if (value != null) {
            return this;
          } else {
            return ret;
          }
        };

        MRTClassShowProgress.prototype.update = function(f) {
          var k, kLast, _i, _j, _ref, _ref1;
          f = Math.min(1, Math.max(0, f));
          kLast = Math.round(this._steps * f);
          if (kLast > 0) {
            for (k = _i = 1; 1 <= kLast ? _i <= kLast : _i >= kLast; k = 1 <= kLast ? ++_i : --_i) {
              this.element[k].show(true);
            }
          }
          if (kLast < this._steps) {
            for (k = _j = _ref = kLast + 1, _ref1 = this._steps; _ref <= _ref1 ? _j <= _ref1 : _j >= _ref1; k = _ref <= _ref1 ? ++_j : --_j) {
              this.element[k].show(false);
            }
          }
          if (f >= 1) {
            return this.remove();
          }
        };

        return MRTClassShowProgress;

      })(MRTClassShowCompoundStimulus);

      MRTClassShow.prototype.SMFigure = function(idx, options) {
        if (options == null) {
          options = {};
        }
        return new MRTClassShowSMFigure(this.root, idx, options);
      };

      MRTClassShow.prototype.MRTClassShowSMFigure = MRTClassShowSMFigure = (function(_super1) {
        __extends(MRTClassShowSMFigure, _super1);

        MRTClassShowSMFigure.prototype._unit_cube = [[[1, 0, 1], [1, 1, 1], [1, 1, 0], [1, 0, 0]], [[0, 0, 1], [1, 0, 1], [1, 0, 0], [0, 0, 0]], [[0, 1, 1], [0, 0, 1], [0, 0, 0], [0, 1, 0]], [[1, 1, 1], [0, 1, 1], [0, 1, 0], [1, 1, 0]], [[0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 0, 1]], [[1, 0, 0], [1, 1, 0], [0, 1, 0], [0, 0, 0]]];

        MRTClassShowSMFigure.prototype._unit_size = null;

        function MRTClassShowSMFigure(root, idx, options) {
          var el, p, path, path_options, _ref, _ref1, _ref2, _ref3, _ref4;
          this.root = root;
          options.color = (_ref = options.color) != null ? _ref : 'white';
          options['stroke-width'] = (_ref1 = options['stroke-width']) != null ? _ref1 : 4;
          options['stroke-linejoin'] = 'round';
          options.cube_size = (_ref2 = options.cube_size) != null ? _ref2 : 50;
          options.theta = (_ref3 = options.theta) != null ? _ref3 : [];
          options.flip = (_ref4 = options.flip) != null ? _ref4 : [false, false, false];
          options.theta.unshift(['x', 180]);
          options.theta.push(['z', -30]);
          options.theta.push(['y', -15]);
          path = this._idx2path(idx, options.theta, options.flip);
          path_options = remove(options, ['cube_size', 'flip', 'theta']);
          el = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = path.length; _i < _len; _i++) {
              p = path[_i];
              _results.push(root.show.Path(p, path_options));
            }
            return _results;
          })();
          MRTClassShowSMFigure.__super__.constructor.call(this, root, el, remove(options, ['color', 'stroke-width', 'stroke-linejoin', 'flip', 'theta']));
        }

        MRTClassShowSMFigure.prototype.attr = function(name, value) {
          var ret;
          switch (name) {
            case "cube_size":
              if (value != null) {
                MRTClassShowSMFigure.__super__.attr.call(this, 'box', this._unit_size * value);
              } else {
                ret = MRTClassShowSMFigure.__super__.attr.call(this, 'box') / this._unit_size;
              }
              break;
            default:
              ret = MRTClassShowSMFigure.__super__.attr.call(this, name, value);
          }
          if (value != null) {
            return this;
          } else {
            return ret;
          }
        };

        MRTClassShowSMFigure.prototype._mmult3dRecursive = function(X, M) {
          var m, x, _i, _j, _len, _len1, _results, _results1;
          if (!Array.isArray(X[0])) {
            _results = [];
            for (_i = 0, _len = M.length; _i < _len; _i++) {
              m = M[_i];
              _results.push(X[0] * m[0] + X[1] * m[1] + X[2] * m[2]);
            }
            return _results;
          } else {
            _results1 = [];
            for (_j = 0, _len1 = X.length; _j < _len1; _j++) {
              x = X[_j];
              _results1.push(this._mmult3dRecursive(x, M));
            }
            return _results1;
          }
        };

        MRTClassShowSMFigure.prototype._smultRecursive = function(X, s) {
          var x, _i, _len, _results;
          if (!Array.isArray(X[0])) {
            return smult(X, s);
          } else {
            _results = [];
            for (_i = 0, _len = X.length; _i < _len; _i++) {
              x = X[_i];
              _results.push(this._smultRecursive(x, s));
            }
            return _results;
          }
        };

        MRTClassShowSMFigure.prototype._paddRecursive = function(X, M) {
          var i, x, _i, _j, _len, _ref, _results, _results1;
          if (!Array.isArray(X[0])) {
            _results = [];
            for (i = _i = 0, _ref = X.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
              _results.push(X[i] + M[i]);
            }
            return _results;
          } else {
            _results1 = [];
            for (_j = 0, _len = X.length; _j < _len; _j++) {
              x = X[_j];
              _results1.push(this._paddRecursive(x, M));
            }
            return _results1;
          }
        };

        MRTClassShowSMFigure.prototype._extentRecursive = function(X, pMin, pMax) {
          var idx, x, _i, _j, _len, _ref, _ref1;
          if (pMin == null) {
            pMin = null;
          }
          if (pMax == null) {
            pMax = null;
          }
          if (!Array.isArray(X[0])) {
            if (pMin != null) {
              for (idx = _i = 0, _ref = X.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; idx = 0 <= _ref ? ++_i : --_i) {
                pMin[idx] = Math.min(pMin[idx], X[idx]);
                pMax[idx] = Math.max(pMax[idx], X[idx]);
              }
              return [pMin, pMax];
            } else {
              return [X.slice(0), X.slice(0)];
            }
          } else {
            for (_j = 0, _len = X.length; _j < _len; _j++) {
              x = X[_j];
              _ref1 = this._extentRecursive(x, pMin, pMax), pMin = _ref1[0], pMax = _ref1[1];
            }
            return [pMin, pMax];
          }
        };

        MRTClassShowSMFigure.prototype._cossin = function(theta) {
          var a;
          a = theta * Math.PI / 180;
          return [Math.cos(a), Math.sin(a)];
        };

        MRTClassShowSMFigure.prototype._rotate3dX = function(P, theta) {
          var c, s, _ref;
          _ref = this._cossin(theta), c = _ref[0], s = _ref[1];
          return this._mmult3dRecursive(P, [[1, 0, 0], [0, c, -s], [0, s, c]]);
        };

        MRTClassShowSMFigure.prototype._rotate3dY = function(P, theta) {
          var c, s, _ref;
          _ref = this._cossin(theta), c = _ref[0], s = _ref[1];
          return this._mmult3dRecursive(P, [[c, 0, s], [0, 1, 0], [-s, 0, c]]);
        };

        MRTClassShowSMFigure.prototype._rotate3dZ = function(P, theta) {
          var c, s, _ref;
          _ref = this._cossin(theta), c = _ref[0], s = _ref[1];
          return this._mmult3dRecursive(P, [[c, -s, 0], [s, c, 0], [0, 0, 1]]);
        };

        MRTClassShowSMFigure.prototype._rotate3d = function(P, theta) {
          var t, _i, _len;
          for (_i = 0, _len = theta.length; _i < _len; _i++) {
            t = theta[_i];
            P = (function() {
              switch (t[0].toLowerCase()) {
                case 'x':
                  return this._rotate3dX(P, t[1]);
                case 'y':
                case 'f':
                  return this._rotate3dY(P, t[1]);
                case 'z':
                case 'l':
                  return this._rotate3dZ(P, t[1]);
                case 'b':
                  return this._rotate3dY(P, -t[1]);
                case 'r':
                  return this._rotate3dZ(P, -t[1]);
                default:
                  throw 'invalid rotation type';
              }
            }).call(this);
          }
          return P;
        };

        MRTClassShowSMFigure.prototype._flip = function(p, flip) {
          var i, _i, _ref, _results;
          _results = [];
          for (i = _i = 0, _ref = p.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
            _results.push((flip[i] ? -1 : 1) * p[i]);
          }
          return _results;
        };

        MRTClassShowSMFigure.prototype._idx2path = function(idx, theta, flip) {
          var fig, path, pos, proj;
          pos = this.root.param.sm_figure[idx];
          fig = this._pos2figure(pos, flip);
          fig = this._rotate3d(fig, theta);
          fig = this._sortCubes(fig);
          proj = this._projectFigure(fig);
          proj = this._scaleProjection(proj);
          path = this._projection2path(proj);
          return path;
        };

        MRTClassShowSMFigure.prototype._pos2cube = function(p) {
          return this._paddRecursive(this._unit_cube, p);
        };

        MRTClassShowSMFigure.prototype._pos2figure = function(P, flip) {
          var p, _i, _len, _results;
          _results = [];
          for (_i = 0, _len = P.length; _i < _len; _i++) {
            p = P[_i];
            _results.push(this._pos2cube(this._flip(p, flip)));
          }
          return _results;
        };

        MRTClassShowSMFigure.prototype._sortCubes = function(fig) {
          var cube, _i, _len, _results;
          fig = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = fig.length; _i < _len; _i++) {
              cube = fig[_i];
              _results.push(this._sortSides(cube));
            }
            return _results;
          }).call(this);
          fig = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = fig.length; _i < _len; _i++) {
              cube = fig[_i];
              _results.push([cube, this._cubeX(cube)]);
            }
            return _results;
          }).call(this);
          fig.sort(function(x, y) {
            return x[1] - y[1];
          });
          _results = [];
          for (_i = 0, _len = fig.length; _i < _len; _i++) {
            cube = fig[_i];
            _results.push(cube[0]);
          }
          return _results;
        };

        MRTClassShowSMFigure.prototype._sortSides = function(cube) {
          var side, _i, _len, _results;
          cube = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = cube.length; _i < _len; _i++) {
              side = cube[_i];
              _results.push([side, this._sideX(side)]);
            }
            return _results;
          }).call(this);
          cube.sort(function(x, y) {
            return x[1] - y[1];
          });
          _results = [];
          for (_i = 0, _len = cube.length; _i < _len; _i++) {
            side = cube[_i];
            _results.push(side[0]);
          }
          return _results;
        };

        MRTClassShowSMFigure.prototype._sideX = function(side) {
          var edge;
          return mean((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = side.length; _i < _len; _i++) {
              edge = side[_i];
              _results.push(edge[0]);
            }
            return _results;
          })());
        };

        MRTClassShowSMFigure.prototype._cubeX = function(cube) {
          var side;
          return mean((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = cube.length; _i < _len; _i++) {
              side = cube[_i];
              _results.push(this._sideX(side));
            }
            return _results;
          }).call(this));
        };

        MRTClassShowSMFigure.prototype._projectFigure = function(fig) {
          var p, _i, _len, _results;
          if (!Array.isArray(fig[0])) {
            return [fig[1], fig[2]];
          } else {
            _results = [];
            for (_i = 0, _len = fig.length; _i < _len; _i++) {
              p = fig[_i];
              _results.push(this._projectFigure(p));
            }
            return _results;
          }
        };

        MRTClassShowSMFigure.prototype._scaleProjection = function(proj) {
          var pMax, pMin, pSub, sDiv, _ref;
          _ref = this._extentRecursive(proj), pMin = _ref[0], pMax = _ref[1];
          pSub = smult(pMin, -1);
          proj = this._paddRecursive(proj, pSub);
          this._unit_size = Math.max.apply(Math, sub(pMax, pMin));
          sDiv = 1 / this._unit_size;
          proj = this._smultRecursive(proj, sDiv);
          return proj;
        };

        MRTClassShowSMFigure.prototype._projection2path = function(proj) {
          var cube, _ref;
          return (_ref = []).concat.apply(_ref, (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = proj.length; _i < _len; _i++) {
              cube = proj[_i];
              _results.push(this._cube2path(cube));
            }
            return _results;
          }).call(this));
        };

        MRTClassShowSMFigure.prototype._cube2path = function(cube) {
          var side, _i, _len, _results;
          _results = [];
          for (_i = 0, _len = cube.length; _i < _len; _i++) {
            side = cube[_i];
            _results.push(this._side2path(side));
          }
          return _results;
        };

        MRTClassShowSMFigure.prototype._side2path = function(side) {
          return [['M', 1 - side[0][0], side[0][1]], ['L', 1 - side[1][0], side[1][1]], ['L', 1 - side[2][0], side[2][1]], ['L', 1 - side[3][0], side[3][1]], ['L', 1 - side[0][0], side[0][1]]];
        };

        return MRTClassShowSMFigure;

      })(MRTClassShowCompoundStimulus);

      return MRTClassShow;

    })(MRTClass);

    MRT.prototype.Input = function() {
      return new MRTClassInput(this);
    };

    MRT.prototype.MRTClassInput = MRTClassInput = (function(_super) {
      __extends(MRTClassInput, _super);

      MRTClassInput.prototype._event_handlers = null;

      MRTClassInput.prototype._handler_count = 0;

      function MRTClassInput(root) {
        MRTClassInput.__super__.constructor.call(this, root);
        this._event_handlers = {};
        $(document).keydown((function(_this) {
          return function(evt) {
            return _this._handleKey(evt, 'down');
          };
        })(this));
        $("\#" + this.root.container).mousedown((function(_this) {
          return function(evt) {
            return _this._handleMouse(evt, 'down');
          };
        })(this));
      }

      MRTClassInput.prototype._touchHandlerType = function(handlerType) {
        if (!(handlerType in this._event_handlers)) {
          return this._event_handlers[handlerType] = {};
        }
      };

      MRTClassInput.prototype._getHandlerType = function(type, subType) {
        var handlerType;
        handlerType = "" + type + "_" + subType;
        this._touchHandlerType(handlerType);
        return handlerType;
      };

      MRTClassInput.prototype._getHandlerID = function(handlerType, key) {
        return [handlerType, key];
      };

      MRTClassInput.prototype._handleEvent = function(evt, handlerType, fCheckHandler) {
        var handler, handlers, key, _results;
        handlers = this.getHandler([handlerType]);
        _results = [];
        for (key in handlers) {
          handler = handlers[key];
          if (fCheckHandler(evt, handler)) {
            handler.f(evt);
            handler.count++;
          }
          if (handler.expires !== 0 && handler.count >= handler.expires) {
            _results.push(this.removeHandler(this._getHandlerID(handlerType, key)));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };

      MRTClassInput.prototype._checkHandlerKeyMouse = function(evt, handler) {
        return contains(handler.button, 'any') || contains(handler.button, evt.which);
      };

      MRTClassInput.prototype._handleKey = function(evt, subType) {
        var handlerType;
        handlerType = this._getHandlerType('key', subType);
        return this._handleEvent(evt, handlerType, this._checkHandlerKeyMouse);
      };

      MRTClassInput.prototype._handleMouse = function(evt, subType) {
        var handlerType;
        handlerType = this._getHandlerType('mouse', subType);
        return this._handleEvent(evt, handlerType, this._checkHandlerKeyMouse);
      };

      MRTClassInput.prototype.addHandler = function(type, options) {
        var handlerType, key, _ref, _ref1, _ref2, _ref3;
        if (options == null) {
          options = null;
        }

        /*add an event handler and return an id for the handler
          type: the type of event to handle. one of the following:
            key: a keyboard event
            mouse: a mouse event
          options:
            f: a function to call when the event occurs. takes the event info as
              input
            expires:  remove the handler after <expires> events, or 0 to never
              expire
            <for key/mouse>:
              sub_type:  the subtype of event to handle. one of the following:
                down: fire handler on key/mouse down
              button: the name of the button that must be pressed for the event to
                fire, or an array of buttons, any one of which will fire the
                event, or 'any' to fire the event for any key/mouse button
         */
        if (options == null) {
          options = {};
        }
        options.f = (_ref = options.f) != null ? _ref : null;
        options.expires = (_ref1 = options.expires) != null ? _ref1 : 0;
        switch (type) {
          case 'key':
          case 'mouse':
            options.sub_type = (_ref2 = options.sub_type) != null ? _ref2 : 'down';
            options.button = forceArray(this.key2code((_ref3 = options.button) != null ? _ref3 : 'any'));
            break;
          default:
            throw "invalid handler type";
        }
        options.count = 0;
        handlerType = this._getHandlerType(type, options.sub_type);
        key = this._handler_count++;
        this._event_handlers[handlerType][key] = options;
        return this._getHandlerID(handlerType, key);
      };

      MRTClassInput.prototype.removeHandler = function(ID) {
        var handlerType, key;
        handlerType = ID[0];
        key = ID[1];
        return delete this._event_handlers[handlerType][key];
      };

      MRTClassInput.prototype.getHandler = function(ID) {
        var handlerType, key;
        handlerType = ID[0];
        if (ID.length > 1) {
          key = ID[1];
          return this._event_handlers[handlerType][key];
        } else {
          return this._event_handlers[handlerType];
        }
      };

      MRTClassInput.prototype.key2code = function(key) {
        var k, _i, _len, _ref, _results;
        if (Array.isArray(key)) {
          _ref = forceArray(key);
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            k = _ref[_i];
            _results.push(this.key2code(k));
          }
          return _results;
        } else {
          switch (key) {
            case 'any':
              return 'any';
            case 'enter':
              return 13;
            case 'left':
              return 37;
            case 'up':
              return 38;
            case 'right':
              return 39;
            case 'down':
              return 40;
            default:
              if ((typeof key) === 'string') {
                return key.toUpperCase().charCodeAt(0);
              } else {
                return key;
              }
          }
        }
      };

      MRTClassInput.prototype.code2key = function(code) {
        switch (code) {
          case 13:
            return 'enter';
          case 37:
            return 'left';
          case 38:
            return 'up';
          case 39:
            return 'right';
          case 40:
            return 'down';
          default:
            if (getClass(code) === 'String') {
              return code;
            } else {
              return String.fromCharCode(code).toLowerCase();
            }
        }
      };

      MRTClassInput.prototype.mouse2code = function(button) {
        var b, _i, _len, _results;
        if (Array.isArray(button)) {
          _results = [];
          for (_i = 0, _len = button.length; _i < _len; _i++) {
            b = button[_i];
            _results.push(this.mouse2code(b));
          }
          return _results;
        } else {
          switch (button) {
            case 'any':
              return 'any';
            case 'left':
              return 1;
            case 'middle':
              return 2;
            case 'right':
              return 3;
            default:
              throw "invalid button";
          }
        }
      };

      MRTClassInput.prototype.code2mouse = function(code) {
        switch (code) {
          case 1:
            return 'left';
          case 2:
            return 'middle';
          case 3:
            return 'right';
          default:
            if (getClass(code) === 'String') {
              return code;
            } else {
              throw 'invalid code';
            }
        }
      };

      return MRTClassInput;

    })(MRTClass);

    MRT.prototype.Time = function() {
      return new MRTClassTime(this);
    };

    MRT.prototype.MRTClassTime = MRTClassTime = (function(_super) {
      __extends(MRTClassTime, _super);

      function MRTClassTime() {
        return MRTClassTime.__super__.constructor.apply(this, arguments);
      }

      MRTClassTime.prototype.Now = function() {
        return new Date().getTime();
      };

      MRTClassTime.prototype.Pause = function(ms) {
        var tStart, _results;
        tStart = this.Now();
        _results = [];
        while (this.Now() < tStart + ms) {
          _results.push(null);
        }
        return _results;
      };

      return MRTClassTime;

    })(MRTClass);

    MRT.prototype.Color = function() {
      return new MRTClassColor(this);
    };

    MRT.prototype.MRTClassColor = MRTClassColor = (function(_super) {
      __extends(MRTClassColor, _super);

      MRTClassColor.prototype.colors = {
        "default": ['crimson', 'red', 'tomato', 'orangered', 'orange', 'gold', 'yellow', 'chartreuse', 'lime', 'limegreen', 'springgreen', 'aqua', 'turquoise', 'deepskyblue', 'blue', 'darkviolet', 'magenta', 'deeppink']
      };

      function MRTClassColor(root) {
        MRTClassColor.__super__.constructor.call(this, root);
        this.colors['difficulty'] = ['blue', 'limegreen', 'gold', 'orange', 'red'];
      }

      MRTClassColor.prototype.pick = function(colorSet, interpolate) {
        var iColor, nColor;
        if (colorSet == null) {
          colorSet = 'default';
        }
        if (interpolate == null) {
          interpolate = false;
        }
        if (interpolate) {
          return this.blend(this.colors[colorSet], Math.random());
        } else {
          nColor = this.colors[colorSet].length;
          iColor = Math.floor(Math.random() * nColor);
          return this.colors[colorSet][iColor];
        }
      };

      MRTClassColor.prototype.blend = function(colorSet, f) {
        var b, colFrom, colTo, fBlend, g, iBlend, iFrom, iTo, nColor, r;
        if (colorSet == null) {
          colorSet = 'default';
        }
        nColor = this.colors[colorSet].length;
        iBlend = Math.max(0, Math.min(nColor - 1, f * (nColor - 1)));
        iFrom = Math.floor(iBlend);
        iTo = Math.min(nColor - 1, iFrom + 1);
        fBlend = iBlend - iFrom;
        colFrom = Raphael.color(this.colors[colorSet][iFrom]);
        colTo = Raphael.color(this.colors[colorSet][iTo]);
        r = (1 - fBlend) * colFrom.r + fBlend * colTo.r;
        g = (1 - fBlend) * colFrom.g + fBlend * colTo.g;
        b = (1 - fBlend) * colFrom.b + fBlend * colTo.b;
        return Raphael.color("rgb(" + r + "," + g + "," + b + ")");
      };

      return MRTClassColor;

    })(MRTClass);

    MRT.prototype.Exec = function() {
      return new MRTClassExec(this);
    };

    MRT.prototype.MRTClassExec = MRTClassExec = (function(_super) {
      var MRTClassExecSequence, MRTClassExecShow;

      __extends(MRTClassExec, _super);

      function MRTClassExec() {
        return MRTClassExec.__super__.constructor.apply(this, arguments);
      }

      MRTClassExec.prototype.Sequence = function(name, fStep, next, options) {
        if (options == null) {
          options = {};
        }
        return new MRTClassExecSequence(this.root, name, fStep, next, options);
      };

      MRTClassExec.prototype.MRTClassExecSequence = MRTClassExecSequence = (function(_super1) {
        __extends(MRTClassExecSequence, _super1);

        MRTClassExecSequence.prototype._fStep = null;

        MRTClassExecSequence.prototype._fQueueStep = null;

        MRTClassExecSequence.prototype._next = null;

        MRTClassExecSequence.prototype._timer = null;

        MRTClassExecSequence.prototype._tStart = null;

        MRTClassExecSequence.prototype._tStep = null;

        MRTClassExecSequence.prototype._fSequencePre = null;

        MRTClassExecSequence.prototype._fSequencePost = null;

        MRTClassExecSequence.prototype._fStepPre = null;

        MRTClassExecSequence.prototype._stepWait = null;

        MRTClassExecSequence.prototype._fStepPost = null;

        MRTClassExecSequence.prototype.name = '';

        MRTClassExecSequence.prototype.description = '';

        MRTClassExecSequence.prototype.time_mode = null;

        MRTClassExecSequence.prototype.sequence_pre = null;

        MRTClassExecSequence.prototype.sequence_post = null;

        MRTClassExecSequence.prototype.finished = false;

        MRTClassExecSequence.prototype.result = null;

        function MRTClassExecSequence(root, name, fStep, next, options) {

          /*
            name: unique name for the sequence
            fStep: array specifying the function to execute at each step. each
              function takes this object and the current step index as input.
            next: array of:
              time: time to move on to the next step
              key: a key that must be down to move on
              f: a function that takes the sequence and step start times and
                returns true to move on
              ['key'/'mouse', options]: specify input event that must occur. see
                MRTClassInput.addHandler for options.
              ['event', f] specify a function that will register an event that
                will call the function to move to the next step
              ['lazy', f] specify a function that will be called after the step is
                executed, take this object and the current step index as inputs,
                and return one of the above
            options:
              description: a description of the sequence
              execute:  true to execute the sequence immediately
              time_mode: the time mode ('step', 'sequence', or 'absolute'):
                step: times are relative to the start of the step
                sequence: times are relative to the start of the sequence
                absolute: times are absolute
              sequence_pre: a function to call immediately before the first step
                executes. takes this object as input. the output is stored in
                @sequence_pre.
              sequence_post: a function to call after the sequence finishes. takes
                this object as input. the output is stored in @sequence_post.
              step_pre: an array of functions to call before each step is
                executed. each function takes this object and the current step
                index as input. the first step's function is called immediately
                after the sequence begins. other steps' functions are called
                immediately after the previous step is executed. output is stored
                in @result[i].pre.
              step_wait: an array of elements that specify what to do while
                waiting for the next stimulus step. outputs are stored in
                @result[i].wait. each element should be one of the following:
                  str: a string/array of strings specifying keys to listen for
                  ['key'/'mouse', options]: an input event to listen for. see
                    MRTClassInput.addHandler for options. if function is specified
                    using options.f, it will receive this object, the event info,
                    and the current step index as inputs.
              step_post: an array of functions to call after each step is
                executed. each function takes this object and the current step
                index as input. the last step's function is called immediately
                before the sequence ends. other steps' functions are called
                immediately before the next step is executed. output is stored in
                @result[i].post.
          
            Note: the results of the sequence are stored in array @result:
              .pre: output from the step's pre function call
              .wait: outputs from the step's wait procedure
              .output: output from the step's function call
              .post: output from the step's post function call
              .t.start: time at which the step started
              .t.end: time at which the step ended
           */
          var do_execute, step, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
          MRTClassExecSequence.__super__.constructor.call(this, root);
          this.name = name;
          this.description = (_ref = options.description) != null ? _ref : this._name;
          this._fSequencePre = (_ref1 = options.sequence_pre) != null ? _ref1 : null;
          this._fSequencePost = (_ref2 = options.sequence_post) != null ? _ref2 : null;
          this._fStepPre = (_ref3 = options.step_pre) != null ? _ref3 : (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = fStep.length; _i < _len; _i++) {
              step = fStep[_i];
              _results.push(null);
            }
            return _results;
          })();
          this._stepWait = (_ref4 = options.step_wait) != null ? _ref4 : (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = fStep.length; _i < _len; _i++) {
              step = fStep[_i];
              _results.push(null);
            }
            return _results;
          })();
          this._fStepPost = (_ref5 = options.step_post) != null ? _ref5 : (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = fStep.length; _i < _len; _i++) {
              step = fStep[_i];
              _results.push(null);
            }
            return _results;
          })();
          do_execute = (_ref6 = options.execute) != null ? _ref6 : true;
          this.time_mode = (_ref7 = options.time_mode) != null ? _ref7 : 'step';
          this._fStep = fStep;
          this._next = next;
          this._prepare_sequence();
          if (do_execute) {
            this.Execute();
          }
        }


        /*number of milliseconds to wait before executing the next step */

        MRTClassExecSequence.prototype._delay_time = function(t) {
          var tExec;
          tExec = (function() {
            switch (this.time_mode) {
              case "step":
                return this._tStep + t;
              case "relative":
                return this._tStart + t;
              case "absolute":
                return t;
              default:
                throw "invalid time mode";
            }
          }).call(this);
          return tExec - this.root.time.Now();
        };


        /*should the next step be executed? */

        MRTClassExecSequence.prototype._check_next = function(fCheck, fStep) {
          if (fCheck(this._tStart, this._tStep)) {
            clearInterval(this._timer);
            return fStep();
          }
        };

        MRTClassExecSequence.prototype._prepare_sequence = function() {
          var idx, nStep, stepName, _i;
          nStep = this._fStep.length;
          this._fQueueStep = [];
          for (idx = _i = 0; 0 <= nStep ? _i <= nStep : _i >= nStep; idx = 0 <= nStep ? ++_i : --_i) {
            stepName = "" + this._name + "_" + idx;
            this.root.queue.add(stepName, ((function(_this) {
              return function(i) {
                return function() {
                  return _this._process_step(i);
                };
              };
            })(this))(idx), {
              "do": false
            });
            this._fQueueStep.push(((function(_this) {
              return function(step) {
                return function() {
                  return _this.root.queue["do"](step);
                };
              };
            })(this))(stepName));
          }
          return this.result = (function() {
            var _j, _ref, _results;
            _results = [];
            for (_j = 0, _ref = nStep - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; 0 <= _ref ? _j++ : _j--) {
              _results.push({
                t: {}
              });
            }
            return _results;
          })();
        };

        MRTClassExecSequence.prototype._process_step = function(idx) {
          var nStep;
          nStep = this._fStep.length;
          if (idx > 0) {
            this._do_step_post(idx - 1);
          } else {
            this._do_sequence_pre();
            this._do_step_pre(idx);
          }
          this._tStep = this.root.time.Now();
          if (idx === nStep) {
            return this._do_sequence_post();
          } else {
            this._do_step(idx);
            if (idx + 1 < nStep) {
              this._do_step_pre(idx + 1);
            }
            return this._parse_next(idx);
          }
        };

        MRTClassExecSequence.prototype._do_sequence_pre = function() {
          this._tStart = this.root.time.Now();
          if (this._fSequencePre != null) {
            return this.sequence_pre = this._fSequencePre(this);
          }
        };

        MRTClassExecSequence.prototype._do_sequence_post = function() {
          this.finished = true;
          if (this._fSequencePost != null) {
            return this.sequence_post = this._fSequencePost(this);
          }
        };

        MRTClassExecSequence.prototype._do_step_pre = function(idx, next) {
          if (next == null) {
            next = null;
          }
          this.result[idx].t.pre = this.root.time.Now();
          if (this._fStepPre[idx] != null) {
            return this.result[idx].pre = this._fStepPre[idx](this, idx);
          }
        };

        MRTClassExecSequence.prototype._do_step = function(idx) {
          this.result[idx].t.start = this.root.time.Now();
          if (this._fStep[idx] != null) {
            this.result[idx].output = this._fStep[idx](this, idx);
          }
          return this._start_waiting(idx);
        };

        MRTClassExecSequence.prototype._do_step_post = function(idx) {
          this._stop_waiting(idx);
          this.result[idx].t.end = this.root.time.Now();
          if (this._fStepPost[idx] != null) {
            return this.result[idx].post = this._fStepPost[idx](this, idx);
          }
        };

        MRTClassExecSequence.prototype._step_start_time = function(idx) {
          return this.result[idx].t.start;
        };

        MRTClassExecSequence.prototype._start_waiting = function(idx) {
          var fHandler, fUser, options, type, _ref, _ref1, _ref2;
          if (this._stepWait[idx] != null) {
            this.result[idx].wait = [];
            switch (getClass(this._stepWait[idx])) {
              case 'String':
                options = {
                  button: this._stepWait[idx]
                };
                this._stepWait[idx] = ['key', options];
                return this._start_waiting(idx);
              case 'Array':
                if (this._stepWait[idx].length > 0 && contains(['key', 'mouse'], this._stepWait[idx][0])) {
                  type = this._stepWait[idx][0];
                  options = this._stepWait[idx].length >= 2 ? this._stepWait[idx][1] : {};
                  options.sub_type = (_ref = options.sub_type) != null ? _ref : 'down';
                  options.button = (_ref1 = options.button) != null ? _ref1 : 'any';
                  options.expires = (_ref2 = options.expires) != null ? _ref2 : 0;
                  fHandler = (function(_this) {
                    return function(evt) {
                      return _this._append_wait_button(idx, type, evt.which);
                    };
                  })(this);
                  if (options.f != null) {
                    fUser = options.f;
                    options.f = (function(_this) {
                      return function(evt) {
                        fUser(_this, evt, idx);
                        return fHandler(evt);
                      };
                    })(this);
                  } else {
                    options.f = fHandler;
                  }
                  return this._stepWait[idx] = ['handler', this.root.input.addHandler(type, options)];
                } else {
                  options = {
                    button: this._stepWait[idx]
                  };
                  this._stepWait[idx] = ['key', options];
                  return this._start_waiting(idx);
                }
                break;
              default:
                throw 'invalid step wait specifier';
            }
          }
        };

        MRTClassExecSequence.prototype._append_wait_button = function(idx, type, button) {
          var code2button, tButton;
          tButton = this.root.time.Now();
          code2button = (function() {
            switch (type) {
              case 'key':
                return this.root.input.code2key;
              case 'mouse':
                return this.root.input.code2mouse;
              default:
                throw 'invalid wait type';
            }
          }).call(this);
          return this.result[idx].wait.push({
            button: code2button(button),
            time: tButton,
            rt: tButton - this._step_start_time(idx)
          });
        };

        MRTClassExecSequence.prototype._stop_waiting = function(idx) {
          if (this._stepWait[idx] != null) {
            switch (this._stepWait[idx][0]) {
              case 'handler':
                return this.root.input.removeHandler(this._stepWait[idx][1]);
              default:
                throw 'what?';
            }
          }
        };

        MRTClassExecSequence.prototype._parse_next = function(idx, next) {
          var fNextStep, fRegisterEvent;
          if (next == null) {
            next = null;
          }
          fNextStep = this._fQueueStep[idx + 1];
          next = next != null ? next : this._next[idx];
          if (!isNaN(parseFloat(next))) {
            return window.setTimeout(fNextStep, this._delay_time(next));
          } else if ((typeof next) === 'string') {
            return this._parse_next(idx, [
              'key', {
                button: next
              }
            ]);
          } else if ((typeof next) === 'function') {
            return this._timer = setInterval(((function(_this) {
              return function(fc, fs) {
                return function() {
                  return _this._check_next(fc, fs);
                };
              };
            })(this))(next, fNextStep), 1);
          } else if (Array.isArray(next) && next.length >= 1) {
            switch (next[0]) {
              case 'key':
              case 'mouse':
                fRegisterEvent = (function(_this) {
                  return function(f) {
                    var fUser, options, _ref, _ref1, _ref2;
                    options = next.length >= 2 ? next[1] : {};
                    options.sub_type = (_ref = options.sub_type) != null ? _ref : 'down';
                    options.button = (_ref1 = options.button) != null ? _ref1 : 'any';
                    options.expires = 1;
                    options.delay = (_ref2 = options.delay) != null ? _ref2 : 0;
                    if (options.f != null) {
                      fUser = options.f;
                      options.f = function() {
                        fUser();
                        return f();
                      };
                    } else {
                      options.f = f;
                    }
                    return _this.root.input.addHandler(next[0], options);
                  };
                })(this);
                return this._parse_next(idx, ['event', fRegisterEvent]);
              case 'event':
                return next[1](fNextStep);
              case 'lazy':
                return this._parse_next(idx, next[1](this, idx));
              default:
                throw "invalid next value";
            }
          } else {
            throw "invalid next value";
          }
        };

        MRTClassExecSequence.prototype.Execute = function() {
          return this._fQueueStep[0]();
        };

        return MRTClassExecSequence;

      })(MRTClass);

      MRTClassExec.prototype.Show = function(name, stim, next, options) {
        if (options == null) {
          options = {};
        }
        return new MRTClassExecShow(this.root, name, stim, next, options);
      };

      MRTClassExec.prototype.MRTClassExecShow = MRTClassExecShow = (function(_super1) {
        __extends(MRTClassExecShow, _super1);

        MRTClassExecShow.prototype._stim = null;

        MRTClassExecShow.prototype._stim_step = null;

        MRTClassExecShow.prototype.remove_stim = null;

        MRTClassExecShow.prototype.fixation = false;

        MRTClassExecShow.prototype.contain = null;

        function MRTClassExecShow(root, name, stim, next, options) {

          /*
            name: a name for the sequence
            stim: an array of arrays of the following (one array for each step):
              [<name of show class>, <arg1 to show class>, ...]
              a Stimulus (hidden)
              a function that takes this object and the current step index and
                returns an array of the above
            next: see MRTClassExecSequence, or
              ['choice', options] (create MRTClassShowChoice from current stimuli)
              ['test', options] (create MRTClassShowTest from current stimuli)
            options:
              step_show: an array of functions to call immediately before each
                stimulus step is shown.  each function takes this object and the
                current step index as input. output is stored in
                @result[i].output.
              remove_stim: when to remove stimuli. one of:
                'step': remove old stimuli at the start of the next step
                'sequence': remove old stimuli at the end of the sequence, hide
                  them at the end of the step
                'sequence_show': remove old stimuli at the end of the sequence,
                  keep them visible at the end of the step
                'none': don't remove stimuli
              fixation: true to show the fixation dot at each step
              contain: true to contain stimuli within the screen
              (see MRTClassExecSequence for more options)
           */
          var s, step_show, _ref, _ref1, _ref2, _ref3;
          step_show = (_ref = options.step_show) != null ? _ref : (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = stim.length; _i < _len; _i++) {
              s = stim[_i];
              _results.push(null);
            }
            return _results;
          })();
          this.remove_stim = (_ref1 = options.remove_stim) != null ? _ref1 : 'step';
          this.fixation = (_ref2 = options.fixation) != null ? _ref2 : false;
          this.contain = (_ref3 = options.contain) != null ? _ref3 : true;
          this._stim = stim;
          this._stim_step = (function() {
            var _i, _ref4, _results;
            _results = [];
            for (_i = 1, _ref4 = stim.length; 1 <= _ref4 ? _i <= _ref4 : _i >= _ref4; 1 <= _ref4 ? _i++ : _i--) {
              _results.push([]);
            }
            return _results;
          })();
          MRTClassExecShow.__super__.constructor.call(this, root, name, step_show, next, options);
        }

        MRTClassExecShow.prototype._do_sequence_post = function() {
          var idx, s, stim, _i, _j, _len, _len1, _ref;
          MRTClassExecShow.__super__._do_sequence_post.call(this);
          if (this.remove_stim === 'sequence' || this.remove_stim === 'sequence_show') {
            _ref = this._stim_step;
            for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
              stim = _ref[idx];
              for (_j = 0, _len1 = stim.length; _j < _len1; _j++) {
                s = stim[_j];
                s.remove();
              }
              if (this.remove_stim === 'sequence_show') {
                this.result[idx].t.remove = this.root.time.Now();
              }
            }
          }
          if (this.remove_stim !== 'none') {
            return this._stim_step = [];
          }
        };

        MRTClassExecShow.prototype._do_step_pre = function(idx) {
          var fixArg, fixObj, stim, stimuli, _i, _len, _results;
          MRTClassExecShow.__super__._do_step_pre.call(this, idx);
          stimuli = forceArray(this._stim[idx]);
          if (this._fixation) {
            fixObj = this.root.fixation[0];
            fixArg = this.root.fixation[1];
            stimuli.push([fixObj].concat(__slice.call(fixArg)));
          }
          _results = [];
          for (_i = 0, _len = stimuli.length; _i < _len; _i++) {
            stim = stimuli[_i];
            _results.push(this._parse_stimulus(stim, idx));
          }
          return _results;
        };

        MRTClassExecShow.prototype._do_step = function(idx) {
          var s, _i, _len, _ref;
          MRTClassExecShow.__super__._do_step.call(this, idx);
          _ref = this._stim_step[idx];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            s = _ref[_i];
            s.show(true);
          }
          return this.result[idx].t.show = this.root.time.Now();
        };

        MRTClassExecShow.prototype._do_step_post = function(idx) {
          var stim, _i, _j, _len, _len1, _ref, _ref1;
          MRTClassExecShow.__super__._do_step_post.call(this, idx);
          if (this.remove_stim === 'step') {
            _ref = this._stim_step[idx];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              stim = _ref[_i];
              stim.remove();
            }
            return this.result[idx].t.remove = this.root.time.Now();
          } else if (this.remove_stim === 'sequence') {
            _ref1 = this._stim_step[idx];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              stim = _ref1[_j];
              stim.show(false);
            }
            return this.result[idx].t.remove = this.root.time.Now();
          }
        };

        MRTClassExecShow.prototype._step_start_time = function(idx) {
          return this.result[idx].t.show;
        };

        MRTClassExecShow.prototype._parse_next = function(idx, next) {
          var fCallback, fNextStep, options, stim, _ref, _ref1;
          if (next == null) {
            next = null;
          }
          next = next != null ? next : this._next[idx];
          if (Array.isArray(next) && (next[0] === 'choice' || next[0] === 'test')) {
            fNextStep = this._fQueueStep[idx + 1];
            options = (_ref = next[1]) != null ? _ref : {};
            fCallback = (_ref1 = options.callback) != null ? _ref1 : null;
            options.callback = (function(_this) {
              return function(obj, i) {
                _this.result[idx].t.choice = obj._tChoice;
                _this.result[idx].t.rt = _this.result[idx].t.choice - _this.result[idx].t.show;
                _this.result[idx].choice = i;
                if (obj instanceof _this.root.show.MRTClassShowTest) {
                  _this.result[idx].correct = obj.correct;
                }
                if (fCallback != null) {
                  fCallback(i);
                }
                return fNextStep();
              };
            })(this);
            stim = this.root.show[capitalize(next[0])](this._stim_step[idx], options);
            return this._store_stimulus(stim, idx);
          } else {
            return MRTClassExecShow.__super__._parse_next.call(this, idx, next);
          }
        };

        MRTClassExecShow.prototype._parse_stimulus = function(stim, idx) {
          var s, _i, _len, _ref, _ref1, _results;
          if (Array.isArray(stim) && stim.length > 0 && (typeof stim[0] === 'string')) {
            return this._parse_stimulus((_ref = this.root.show)[stim[0]].apply(_ref, stim.slice(1)), idx);
          } else if (stim != null) {
            _ref1 = forceArray(stim);
            _results = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              s = _ref1[_i];
              if (s instanceof this.root.show.MRTClassShowStimulus) {
                this._store_stimulus(s, idx);
                if (this.contain) {
                  s.contain();
                }
                _results.push(s.show(false));
              } else if (s instanceof Function) {
                _results.push(this._parse_stimulus(s(this, idx), idx));
              } else if (Array.isArray(s)) {
                _results.push(this._parse_stimulus(s, idx));
              } else {
                throw "invalid stimulus";
              }
            }
            return _results;
          } else {
            return null;
          }
        };

        MRTClassExecShow.prototype._store_stimulus = function(stim, idx) {
          this._stim_step[idx].push(stim);
          return stim;
        };

        return MRTClassExecShow;

      })(MRTClassExecSequence);

      return MRTClassExec;

    })(MRTClass);

    MRT.prototype.Queue = function() {
      return new MRTClassQueue(this);
    };

    MRT.prototype.MRTClassQueue = MRTClassQueue = (function(_super) {
      __extends(MRTClassQueue, _super);

      MRTClassQueue.prototype._queue = null;

      function MRTClassQueue(root) {
        MRTClassQueue.__super__.constructor.call(this, root);
        this.clear();
      }

      MRTClassQueue.prototype.length = function() {
        return this._queue.length;
      };

      MRTClassQueue.prototype.add = function(name, f, options) {
        var _ref;
        if (options == null) {
          options = {};
        }
        options["do"] = (_ref = options["do"]) != null ? _ref : true;
        this._queue.push({
          name: name,
          f: f,
          ready: false
        });
        if (options["do"]) {
          return this["do"](name);
        }
      };

      MRTClassQueue.prototype["do"] = function(name) {
        var i, _i, _ref, _results, _results1;
        if (name == null) {
          name = null;
        }
        if (this._queue.length > 0) {
          if ((name == null) && this._queue[0].ready) {
            return this["do"](this._queue[0].name);
          } else if (this._queue[0].name === name && this.root.ready()) {
            this._queue[0].ready = true;
            _results = [];
            while (this._queue.length > 0 && this._queue[0].ready) {
              _results.push(this._queue.shift().f());
            }
            return _results;
          } else {
            _results1 = [];
            for (i = _i = 0, _ref = this._queue.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
              if (this._queue[i].name === name) {
                this._queue[i].ready = true;
                break;
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          }
        }
      };

      MRTClassQueue.prototype.clear = function() {
        return this._queue = [];
      };

      return MRTClassQueue;

    })(MRTClass);

    MRT.prototype.Data = function() {
      return new MRTClassData(this);
    };

    MRT.prototype.MRTClassData = MRTClassData = (function(_super) {
      var MRTClassDataVariable;

      __extends(MRTClassData, _super);

      MRTClassData.prototype.timeout = null;

      MRTClassData.prototype._local = false;

      MRTClassData.prototype._local_datastore = null;

      MRTClassData.prototype._archive = null;

      MRTClassData.prototype._numBusy = 0;

      MRTClassData.prototype._failed = false;

      MRTClassData.prototype._failSafeExecuted = false;

      MRTClassData.prototype._failSafeCallback = null;

      function MRTClassData(root, options) {
        var _ref;
        if (options == null) {
          options = {};
        }
        MRTClassData.__super__.constructor.call(this, root);
        this.timeout = (_ref = options.timeout) != null ? _ref : 10000;
        this._local = options.local;
        this._local_datastore = {};
        this._archive = {};
        this.load();
      }

      MRTClassData.prototype.load = function() {
        this.block('loading data');
        return this.read('keys', {
          store: false,
          callback: (function(_this) {
            return function(result) {
              return _this.loadCallback(result);
            };
          })(this)
        });
      };

      MRTClassData.prototype.loadCallback = function(result) {
        var key, keys, _i, _len, _ref, _results;
        keys = (_ref = result.value) != null ? _ref : null;
        if (keys != null) {
          _results = [];
          for (_i = 0, _len = keys.length; _i < _len; _i++) {
            key = keys[_i];
            this._numBusy++;
            _results.push(this.read(key, {
              callback: (function(_this) {
                return function(result) {
                  return _this.unblock();
                };
              })(this)
            }));
          }
          return _results;
        } else {
          return this.unblock();
        }
      };

      MRTClassData.prototype.save = function(options) {
        var key, time, _ref, _ref1, _results;
        if (options == null) {
          options = {};
        }
        options.callback = (_ref = options.callback) != null ? _ref : null;
        options.previous_failure = (_ref1 = options.previous_failure) != null ? _ref1 : this._failed;
        this.block('saving data');
        for (key in this._local_datastore) {
          this._numBusy++;
          this.write(key, this._local_datastore[key], {
            store: false,
            callback: (function(_this) {
              return function(result) {
                return _this.saveCallback(result, options);
              };
            })(this)
          });
        }
        _results = [];
        for (key in this._archive) {
          _results.push((function() {
            var _results1;
            _results1 = [];
            for (time in this._archive[key]) {
              this._numBusy++;
              _results1.push(this.archive(key, {
                store: false,
                time: time,
                callback: (function(_this) {
                  return function(result) {
                    return _this.saveCallback(result, options);
                  };
                })(this)
              }));
            }
            return _results1;
          }).call(this));
        }
        return _results;
      };

      MRTClassData.prototype.saveCallback = function(result, options) {
        if (options.callback != null) {
          this.root.queue.add('save_callback', (function(_this) {
            return function() {
              return options.callback();
            };
          })(this));
        }
        if (!result.success && options.previous_failure) {
          return this.failSafe({
            callback: (function(_this) {
              return function() {
                return _this.unblock();
              };
            })(this)
          });
        } else {
          return this.unblock();
        }
      };

      MRTClassData.prototype.block = function(description) {
        this._numBusy = 0;
        return this.root.queue.add('data_block', (function() {
          return null;
        }), {
          "do": false
        });
      };

      MRTClassData.prototype.unblock = function() {
        if (this._numBusy > 0) {
          this._numBusy--;
        }
        if (this._numBusy === 0) {
          return this.root.queue["do"]('data_block');
        }
      };

      MRTClassData.prototype.ajax = function(data, options) {
        data.csrfmiddlewaretoken = this.root.csrf;
        data.user = this.root.subject;
        return $.ajax({
          type: 'POST',
          url: '/mrt/data/',
          data: data,
          success: (function(_this) {
            return function(result) {
              return _this["" + data.action + "Callback"](result, options);
            };
          })(this),
          error: (function(_this) {
            return function(jqXHR, status, err) {
              return _this.failure();
            };
          })(this),
          timeout: this.timeout
        });
      };

      MRTClassData.prototype.read = function(key, options) {
        var data, result, _ref, _ref1, _ref2;
        if (options == null) {
          options = {};
        }
        options.force_remote = (_ref = options.force_remote) != null ? _ref : false;
        options.store = (_ref1 = options.store) != null ? _ref1 : true;
        options.callback = (_ref2 = options.callback) != null ? _ref2 : null;
        if (this._local || (!options.force_remote && key in this._local_datastore)) {
          result = {
            success: true,
            action: 'read',
            key: key,
            status: key in this._local_datastore ? 'read' : 'nonexistent',
            value: this._local_datastore[key]
          };
          return window.setTimeout(((function(_this) {
            return function() {
              return _this.readCallback(result, options);
            };
          })(this)), 0);
        } else {
          data = {
            action: 'read',
            key: key
          };
          return this.ajax(data, options);
        }
      };

      MRTClassData.prototype.readCallback = function(result, options) {
        if (result.success) {
          if (options.store && result.status === 'read') {
            this._local_datastore[result.key] = result.value;
          }
        } else {
          this.failure();
        }
        if (options.callback != null) {
          return options.callback(result);
        }
      };

      MRTClassData.prototype.write = function(key, value, options) {
        var data, newKey, result, _ref, _ref1;
        if (options == null) {
          options = {};
        }
        options.store = (_ref = options.store) != null ? _ref : true;
        options.callback = (_ref1 = options.callback) != null ? _ref1 : null;
        if (options.store) {
          newKey = !(key in this._local_datastore);
          this._local_datastore[key] = value;
          if (newKey) {
            this.write('keys', Object.keys(this._local_datastore), {
              store: false
            });
          }
        }
        if (this._local) {
          result = {
            success: true,
            action: 'write',
            key: key,
            status: 'write'
          };
          return window.setTimeout(((function(_this) {
            return function() {
              return _this.writeCallback(result, options);
            };
          })(this)), 0);
        } else {
          data = {
            action: 'write',
            key: key,
            value: JSON.stringify(value)
          };
          return this.ajax(data, options);
        }
      };

      MRTClassData.prototype.writeCallback = function(result, options) {
        if (!result.success) {
          this.failure();
        }
        if (options.callback != null) {
          return options.callback(result);
        }
      };

      MRTClassData.prototype.archive = function(key, options) {
        var data, result, _ref, _ref1, _ref2;
        if (options == null) {
          options = {};
        }
        options.store = (_ref = options.store) != null ? _ref : true;
        options.callback = (_ref1 = options.callback) != null ? _ref1 : null;
        options.time = (_ref2 = options.time) != null ? _ref2 : this.root.time.Now();
        if (options.store) {
          if (!(key in this._archive)) {
            this._archive[key] = {};
          }
          this._archive[key][options.time] = this._local_datastore[key];
        }
        if (this._local) {
          result = {
            success: true,
            action: 'archive',
            key: key,
            status: 'archive',
            time: options.time
          };
          return window.setTimeout(((function(_this) {
            return function() {
              return _this.archiveCallback(result, options);
            };
          })(this)), 0);
        } else {
          data = {
            action: 'archive',
            key: key,
            time: options.time,
            value: JSON.stringify(this._local_datastore[key])
          };
          return this.ajax(data, options);
        }
      };

      MRTClassData.prototype.archiveCallback = function(result, options) {
        if (!result.success) {
          this.failure();
        }
        if (options.callback != null) {
          return options.callback(result);
        }
      };

      MRTClassData.prototype.failure = function() {
        return this._failed = true;
      };

      MRTClassData.prototype.failSafe = function(options) {
        var failSafeData, mailBody, mailSubject, _ref;
        if (!this._failSafeExecuted) {
          this._failSafeCallback = (_ref = options.callback) != null ? _ref : null;
          this._failSafeExecuted = true;
          failSafeData = "" + (JSON.stringify(this._local_datastore)) + "\n\n" + (JSON.stringify(this._archive));
          $('#failsafe_data').val(failSafeData);
          mailSubject = encodeURIComponent("Session Data for " + this.root.subject);
          mailBody = failSafeData.length < 2000 ? encodeURIComponent(failSafeData) : '';
          $('#failsafe_mailto').attr("href", "mailto:schlegel@gmail.com?subject=" + mailSubject + "&body=" + mailBody);
          return $('#failsafe').show();
        } else {
          if (options.callback) {
            return options.callback();
          }
        }
      };

      MRTClassData.prototype.failSafeHide = function() {
        $('#failsafe').hide();
        if (this._failSafeCallback != null) {
          return this._failSafeCallback();
        }
      };

      MRTClassData.prototype.Variable = function(key, value, options) {
        if (options == null) {
          options = {};
        }
        return new MRTClassDataVariable(this, key, value, options);
      };

      MRTClassData.prototype.MRTClassDataVariable = MRTClassDataVariable = (function() {
        MRTClassDataVariable.prototype.track = false;

        MRTClassDataVariable.prototype._data = null;

        MRTClassDataVariable.prototype._key = null;

        MRTClassDataVariable.prototype._value = null;

        MRTClassDataVariable.prototype._initialized = false;

        function MRTClassDataVariable(data, key, value, options) {

          /*
            data: the parent MRTClassData object
            key: the variable name
            value: the variable value
            options:
              track: true to archive each change to the variable
              timeout: the number of milliseconds before the variable value resets
                to its initial value
              timeout_type: one of the following:
                'session': value will only reset in between sessions
                'instant': value will reset immediately after timeout
              callback: a function that takes the variable as an input and is
                called after the variable is initialized
           */
          var _ref, _ref1, _ref2, _ref3;
          this._data = data;
          this.track = (_ref = options.track) != null ? _ref : false;
          options.timeout = (_ref1 = options.timeout) != null ? _ref1 : null;
          options.timeout_type = (_ref2 = options.timeout_type) != null ? _ref2 : 'session';
          options.callback = (_ref3 = options.callback) != null ? _ref3 : null;
          this._key = key;
          this._value = {
            value: value
          };
          if (options.timeout != null) {
            this._value.timeout = options.timeout;
            this._value.timeout_type = options.timeout_type;
          }
          this.update(options);
        }

        MRTClassDataVariable.prototype.update = function(options) {
          if (options == null) {
            options = {};
          }
          return this._data.read(this._key, {
            callback: (function(_this) {
              return function(result) {
                return _this.dataCallback(result, options);
              };
            })(this)
          });
        };

        MRTClassDataVariable.prototype.initialize = function() {
          if (this._value.timeout != null) {
            this._value.initial = this._value.value;
          }
          return this.reset();
        };

        MRTClassDataVariable.prototype.reset = function() {
          if (this._value.timeout != null) {
            this._value.reset_time = this._data.root.time.Now();
            return this.set(this._value.initial);
          } else {
            return this.set(this._value.value);
          }
        };

        MRTClassDataVariable.prototype.dataCallback = function(result, options) {
          var _ref;
          if (options == null) {
            options = {};
          }
          options.callback = (_ref = options.callback) != null ? _ref : null;
          if (result.success) {
            switch (result.status) {
              case 'nonexistent':
                this.initialize();
                break;
              case 'read':
                this._value = result.value;
                this.checkTimeout();
                break;
              case 'write':
                if (this.track && (this.get() != null)) {
                  this._data.archive(this._key, {
                    callback: (function(_this) {
                      return function(result) {
                        return _this.dataCallback(result);
                      };
                    })(this)
                  });
                }
                this.checkTimeout();
                break;
              case 'archive':
                null;
                break;
              default:
                null;
            }
            if (!this._initialized) {
              this._initialized = true;
            }
            if (options.callback != null) {
              return options.callback(this);
            }
          }
        };

        MRTClassDataVariable.prototype.checkTimeout = function() {
          if ((this._value.timeout != null) && (this._value.timeout_type === 'instant' || !this._initialized)) {
            if (this._data.root.time.Now() >= this.nextReset()) {
              return this.reset();
            }
          }
        };

        MRTClassDataVariable.prototype.nextReset = function() {
          if (this._value.timeout != null) {
            return this._value.reset_time + this._value.timeout;
          } else {
            return null;
          }
        };

        MRTClassDataVariable.prototype.get = function() {
          return this._value.value;
        };

        MRTClassDataVariable.prototype.set = function(value) {
          this._value.value = value;
          this._data.write(this._key, this._value, {
            callback: (function(_this) {
              return function(result) {
                return _this.dataCallback(result);
              };
            })(this)
          });
          return this;
        };

        return MRTClassDataVariable;

      })();

      return MRTClassData;

    })(MRTClass);

    MRT.prototype.Session = function() {
      return new MRTClassSession(this);
    };

    MRT.prototype.MRTClassSession = MRTClassSession = (function(_super) {
      __extends(MRTClassSession, _super);

      MRTClassSession.prototype._started = false;

      MRTClassSession.prototype._responded = false;

      MRTClassSession.prototype._result_idx = 0;

      MRTClassSession.prototype._sequence = null;

      MRTClassSession.prototype._base_param = null;

      MRTClassSession.prototype.stim_figure_prompt = null;

      MRTClassSession.prototype.stim_figure_target = null;

      MRTClassSession.prototype.stim_prompt = null;

      MRTClassSession.prototype.current_trial = 0;

      MRTClassSession.prototype.response_map = null;

      function MRTClassSession(root) {
        this.subjectResponse = __bind(this.subjectResponse, this);
        this.run = __bind(this.run, this);
        MRTClassSession.__super__.constructor.call(this, root);
        this.base_param = {};
        this.response_map = {
          left: true,
          right: false
        };
      }

      MRTClassSession.prototype.remaining = function() {
        return this.getSequence().length - this.current_trial;
      };

      MRTClassSession.prototype.run = function(param) {
        if (param == null) {
          param = null;
        }
        if (!this._started) {
          return this.start(param);
        } else if (this.remaining() > 0) {
          return this.step();
        } else {
          return this.finish();
        }
      };

      MRTClassSession.prototype.start = function(param) {
        if (param == null) {
          param = null;
        }
        this.setSequence(param);
        this._base_param = param != null ? param : this.root.param.getBase();
        this.root.dbg.showDuration();
        if (this.setSubject()) {
          return this.instructSession({
            sequence_post: (function(_this) {
              return function(shw) {
                _this._started = true;
                return _this.run();
              };
            })(this)
          });
        } else {
          return this.root.dbg.clear();
        }
      };

      MRTClassSession.prototype.step = function() {
        var param;
        this.root.dbg.set('trial', this.current_trial + 1);
        param = copy(this._base_param);
        param.trial = this.root.param.fill(param.trial, 'trial', false);
        param.stimulus = this.getSequence(this.current_trial);
        this.doTrial(param, {
          callback: (function(_this) {
            return function(shw) {
              return setTimeout(_this.run, param.trial.iti);
            };
          })(this)
        });
        return this.current_trial++;
      };

      MRTClassSession.prototype.finish = function() {
        return this.root.show.Instructions('Finished!');
      };

      MRTClassSession.prototype.code2response = function(code) {
        var key;
        key = this.root.input.code2key(code);
        if (key in this.response_map) {
          return this.response_map[key];
        } else {
          return null;
        }
      };

      MRTClassSession.prototype.setSubject = function() {
        var subject;
        subject = prompt('subject id:', this.root.default_subject);
        if (subject != null) {
          this.root.subject = subject;
          return true;
        } else {
          return false;
        }
      };

      MRTClassSession.prototype.setSequence = function(param) {
        var angle, dir, f, idx, idx_match, match, num_match, rotate_angle, rotate_dir, seq_norotate, seq_rotate, stim, t, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _n, _o, _ref, _ref1, _ref2, _ref3;
        if (param == null) {
          param = null;
        }
        param = param != null ? copy(param, true) : {};
        if (param.stimulus == null) {
          param.stimulus = {};
        }
        this.root.setSeed();
        param.sequence = this.root.param.fill(param.sequence, 'sequence', false);
        rotate_dir = forceArray(this.root.param.fillBase(param.stimulus.rotate_dir, 'stimulus', 'rotate_dir'));
        rotate_angle = forceArray(this.root.param.fillBase(param.stimulus.rotate_angle, 'stimulus', 'rotate_angle'));
        match = this.root.param.isEmpty(param.stimulus.match) ? ((_ref = dec2frac(param.sequence.match_ratio), t = _ref[0], f = _ref[1], _ref), ((function() {
          var _i, _results;
          _results = [];
          for (_i = 1; 1 <= t ? _i <= t : _i >= t; 1 <= t ? _i++ : _i--) {
            _results.push(true);
          }
          return _results;
        })()).concat((function() {
          var _i, _results;
          _results = [];
          for (_i = 1; 1 <= f ? _i <= f : _i >= f; 1 <= f ? _i++ : _i--) {
            _results.push(false);
          }
          return _results;
        })())) : forceArray(param.stimulus.match);
        num_match = match.length;
        this._sequence = [];
        for (_i = 0, _len = rotate_dir.length; _i < _len; _i++) {
          dir = rotate_dir[_i];
          for (_j = 0, _len1 = rotate_angle.length; _j < _len1; _j++) {
            angle = rotate_angle[_j];
            idx_match = 0;
            for (_k = 1, _ref1 = param.sequence.trials_per_condition; 1 <= _ref1 ? _k <= _ref1 : _k >= _ref1; 1 <= _ref1 ? _k++ : _k--) {
              param.stimulus.rotate_dir = dir;
              param.stimulus.rotate_angle = angle;
              param.stimulus.match = match[idx_match];
              stim = this.root.param.fill(param.stimulus, 'stimulus', false);
              this._sequence.push(stim);
              idx_match = (idx_match + 1) % num_match;
            }
          }
        }
        randomize(this._sequence);
        if (param.sequence.interleave_norotation) {
          param.stimulus.rotate_angle = 0;
          seq_norotate = [];
          for (_l = 0, _len2 = rotate_dir.length; _l < _len2; _l++) {
            dir = rotate_dir[_l];
            for (_m = 0, _len3 = rotate_angle.length; _m < _len3; _m++) {
              angle = rotate_angle[_m];
              idx_match = 0;
              for (_n = 1, _ref2 = param.sequence.trials_per_condition; 1 <= _ref2 ? _n <= _ref2 : _n >= _ref2; 1 <= _ref2 ? _n++ : _n--) {
                param.stimulus.rotate_dir = dir;
                param.stimulus.match = match[idx_match];
                stim = this.root.param.fill(param.stimulus, 'stimulus', false);
                seq_norotate.push(stim);
                idx_match = (idx_match + 1) % num_match;
              }
            }
          }
          randomize(seq_norotate);
          seq_rotate = this._sequence;
          this._sequence = [];
          for (idx = _o = 0, _ref3 = seq_rotate.length - 1; 0 <= _ref3 ? _o <= _ref3 : _o >= _ref3; idx = 0 <= _ref3 ? ++_o : --_o) {
            this._sequence.push(seq_rotate[idx]);
            this._sequence.push(seq_norotate[idx]);
          }
          this._sequence.pop();
        }
        return this.root.dbg.set('num_trials', this._sequence.length);
      };

      MRTClassSession.prototype.getSequence = function(idx_trial) {
        if (idx_trial == null) {
          idx_trial = null;
        }
        if (this._sequence == null) {
          this.setSequence();
        }
        if (idx_trial != null) {
          return this._sequence[idx_trial];
        } else {
          return this._sequence;
        }
      };

      MRTClassSession.prototype.instructSession = function(options) {
        var next, stim;
        if (options == null) {
          options = null;
        }
        stim = [];
        next = [];
        stim.push([['Instructions', "\<Instructions Go Here\>\n \nFor now:\nPress \u2190 for \"same\"\nand \u2192 for \"different\"\n \nPress any key to continue."]]);
        next.push('any');
        stim.push([['Instructions', "Press any key to begin the experiment."]]);
        next.push('any');
        return this.root.exec.Show('instruction', stim, next, options);
      };

      MRTClassSession.prototype.clearStimulus = function() {
        if (this.stim_figure_prompt != null) {
          this.stim_figure_prompt.remove();
        }
        if (this.stim_figure_target != null) {
          this.stim_figure_target.remove();
        }
        if (this.stim_prompt != null) {
          return this.stim_prompt.remove();
        }
      };

      MRTClassSession.prototype.getAngleText = function(param) {
        return param.rotate_angle + '\u00B0';
      };

      MRTClassSession.prototype.getPromptText = function(param) {
        var strPrompt;
        if (param.rotate_angle === 0) {
          strPrompt = 'N';
        } else {
          strPrompt = param.rotate_dir;
          if (param.show_angle) {
            strPrompt += ' ' + this.getAngleText(param);
          }
        }
        return strPrompt;
      };

      MRTClassSession.prototype.showPrompt = function(param, options) {
        var a, flip, strPrompt, x, y, yPrompt;
        if (options == null) {
          options = null;
        }
        options = options != null ? options : {};
        flip = [param.flip_x, param.flip_y, param.flip_z];
        a = param.position * Math.PI / 4 + Math.PI;
        x = param.offset * Math.cos(a);
        y = param.offset * Math.sin(a);
        this.stim_figure_prompt = this.root.show.SMFigure(param.idx, {
          x: x,
          y: y,
          cube_size: param.cube_size,
          'stroke-width': param.edge,
          flip: flip,
          show: options.show
        });
        strPrompt = this.getPromptText(param);
        yPrompt = this.stim_figure_prompt.attr('y') - this.stim_figure_prompt.attr('height') / 2 - param.font_size / 2;
        this.stim_prompt = this.root.show.Text(strPrompt, {
          x: this.stim_figure_prompt.attr('x'),
          y: yPrompt,
          'font-size': param.font_size,
          show: options.show
        });
        return [this.stim_figure_prompt, this.stim_prompt];
      };

      MRTClassSession.prototype.showTarget = function(param, options) {
        var a, flip, x, y;
        if (options == null) {
          options = null;
        }
        options = options != null ? options : {};
        flip = [param.flip_x === param.match, param.flip_y, param.flip_z];
        a = param.position * Math.PI / 4;
        x = param.offset * Math.cos(a);
        y = param.offset * Math.sin(a);
        this.stim_figure_target = this.root.show.SMFigure(param.idx, {
          x: x,
          y: y,
          cube_size: param.cube_size,
          'stroke-width': param.edge,
          flip: flip,
          theta: [[param.rotate_dir, param.rotate_angle]],
          show: options.show
        });
        return [this.stim_figure_target];
      };

      MRTClassSession.prototype.showStimulus = function(param, options) {
        if (options == null) {
          options = null;
        }
        options = options != null ? options : {};
        return this.showPrompt(param, options).concat(this.showTarget(param, options));
      };

      MRTClassSession.prototype.doTrial = function(param, options) {
        var f, next, shw, stim, trialName, _ref;
        if (options == null) {
          options = null;
        }
        this._responded = false;
        options = options != null ? options : {};
        options.remove_stim = 'sequence_show';
        stim = [];
        options.step_wait = [];
        next = [];
        if (param.trial.target_delay === 0) {
          this._result_idx = 0;
          stim.push(this.showStimulus(param.stimulus, {
            show: false
          }));
          options.step_wait.push([
            'key', {
              button: 'any',
              f: this.subjectResponse
            }
          ]);
          next.push(param.trial.duration);
        } else {
          this._result_idx = 1;
          stim.push(this.showPrompt(param.stimulus, {
            show: false
          }));
          options.step_wait.push(null);
          next.push(param.trial.target_delay);
          stim.push(this.showTarget(param.stimulus, {
            show: false
          }));
          options.step_wait.push([
            'key', {
              button: 'any',
              f: this.subjectResponse
            }
          ]);
          next.push(param.trial.duration - param.trial.target_delay);
        }
        f = (_ref = options.callback) != null ? _ref : null;
        options.sequence_post = (function(_this) {
          return function(shw) {
            _this.endTrial(shw, param);
            if (f != null) {
              return f(shw);
            }
          };
        })(this);
        trialName = this.trialName({
          trial: options.trial
        });
        return shw = this.root.exec.Show("" + trialName, stim, next, options);
      };

      MRTClassSession.prototype.subjectResponse = function(s, evt, idx) {
        var colResponse, response, stimResponse, strResponse;
        if (!this._responded) {
          this._responded = true;
          response = this.code2response(evt.which);
          if (response != null) {
            strResponse = response ? 'S' : 'D';
            colResponse = 'limegreen';
          } else {
            strResponse = 'X';
            colResponse = 'red';
          }
          stimResponse = this.root.show.Text(strResponse, {
            'font-weight': 'bold',
            color: colResponse
          });
          return s._store_stimulus(stimResponse, idx);
        }
      };

      MRTClassSession.prototype.trialName = function(options) {
        var trial, _ref;
        if (options == null) {
          options = {};
        }
        trial = (_ref = options.trial) != null ? _ref : this.current_trial;
        return "trial" + trial;
      };

      MRTClassSession.prototype.endTrial = function(shw, param) {
        return this.root.dbg.set('result', this.trialResult(shw, param));
      };

      MRTClassSession.prototype.trialResult = function(shw, param) {
        var result, result_response;
        result = copy(param.stimulus);
        result_response = shw.result[this._result_idx].wait[0];
        if (result_response) {
          result.response = this.code2response(result_response.button);
          result.correct = result.match === result.response;
          result.rt = result_response.rt + param.trial.target_delay;
        } else {
          result.response = null;
          result.correct = false;
          result.rt = null;
        }
        return result;
      };

      return MRTClassSession;

    })(MRTClass);

    MRT.prototype.Param = function() {
      return new MRTClassParam(this);
    };

    MRT.prototype.MRTClassParam = MRTClassParam = (function(_super) {
      __extends(MRTClassParam, _super);

      MRTClassParam.prototype._presets = null;

      MRTClassParam.prototype._base = null;

      MRTClassParam.prototype._min_window_dim = function() {
        return Math.min(this.root.width(), this.root.height());
      };

      MRTClassParam.prototype._default_cube_size = function() {
        return Math.round(this._min_window_dim() / 20);
      };

      MRTClassParam.prototype._default_offset = function() {
        return Math.round(this._min_window_dim() / 4);
      };

      MRTClassParam.prototype._default_edge = function() {
        return Math.max(1, Math.round(this._min_window_dim() / 200));
      };

      MRTClassParam.prototype._default_font_size = function() {
        return Math.round(this._min_window_dim() / 20);
      };

      MRTClassParam.prototype.sm_figure = [[[0, 0, 0], [0, 1, 0], [0, 2, 0], [0, 3, 0], [0, 3, 1], [0, 0, 1], [0, 0, 2], [0, 0, 3], [1, 0, 3], [2, 0, 3]], [[0, 0, 0], [0, 1, 0], [0, 2, 0], [0, 3, 0], [-1, 3, 0], [0, 0, 1], [0, 0, 2], [0, 0, 3], [1, 0, 3], [2, 0, 3]], [[0, 0, 0], [0, 1, 0], [0, 2, 0], [0, 3, 0], [0, 3, -1], [0, 0, 1], [0, 0, 2], [0, 0, 3], [-1, 0, 3], [-2, 0, 3]], [[0, 0, 0], [0, 1, 0], [0, 2, 0], [0, 3, 0], [-1, 3, 0], [0, 0, 1], [0, 0, 2], [0, 0, 3], [0, -1, 3], [0, -2, 3]], [[0, 0, 0], [0, 1, 0], [0, 2, 0], [0, 3, 0], [0, 0, 1], [0, 0, 2], [0, 0, 3], [-1, 0, 3], [-2, 0, 3], [-2, -1, 3]], [[0, 0, 0], [0, 1, 0], [0, 2, 0], [1, 2, 0], [2, 2, 0], [3, 2, 0], [0, 0, 1], [0, 0, 2], [0, 0, 3], [-1, 0, 3]], [[0, 0, 0], [0, 1, 0], [0, 2, 0], [0, 3, 0], [1, 3, 0], [2, 3, 0], [0, 0, 1], [0, 0, 2], [0, 0, 3], [-1, 0, 3], [-2, 0, 3]], [[0, 0, 0], [0, 1, 0], [0, 2, 0], [1, 2, 0], [2, 2, 0], [0, 0, 1], [0, 0, 2], [0, 0, 3], [-1, 0, 3], [-2, 0, 3]]];

      function MRTClassParam(root) {
        this._default_font_size = __bind(this._default_font_size, this);
        this._default_edge = __bind(this._default_edge, this);
        this._default_offset = __bind(this._default_offset, this);
        this._default_cube_size = __bind(this._default_cube_size, this);
        this._min_window_dim = __bind(this._min_window_dim, this);
        var _i, _ref, _results;
        MRTClassParam.__super__.constructor.call(this, root);
        this._presets = {};
        this._presets["default"] = {
          sequence: {
            trials_per_condition: 9,
            match_ratio: 2,
            interleave_norotation: false
          },
          trial: {
            duration: 6000,
            target_delay: 1000,
            iti: 6000
          },
          stimulus: {
            match: [false, true],
            idx: (function() {
              _results = [];
              for (var _i = 0, _ref = this.sm_figure.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
              return _results;
            }).apply(this),
            rotate_dir: ['F', 'B', 'L', 'R'],
            rotate_angle: [0, 45, 90, 135],
            position: [0, 1, 2, 3, 4, 5, 6, 7],
            flip_x: false,
            flip_y: false,
            flip_z: false,
            show_angle: true,
            cube_size: this._default_cube_size,
            offset: this._default_offset,
            edge: this._default_edge,
            font_size: this._default_font_size
          }
        };
        this._presets.interleave_norotation = copy(this._presets["default"], true);
        this._presets.interleave_norotation.sequence.interleave_norotation = true;
        this._presets.interleave_norotation.trial.iti = 0;
        this._presets.interleave_norotation.stimulus.rotate_angle = this._presets["default"].stimulus.rotate_angle.slice(1);
        this.setBase('default');
      }

      MRTClassParam.prototype.setBase = function(x) {
        switch (getClass(x)) {
          case 'String':
            return this._base = this._presets[x];
          case 'Object':
            return x;
          default:
            throw 'invalid base';
        }
      };

      MRTClassParam.prototype.getBase = function() {
        return copy(this._base, true);
      };

      MRTClassParam.prototype.isEmpty = function(val) {
        return (val == null) || (getClass(val) === 'Number' && isNaN(val)) || (getClass(val) === 'String' && val.length === 0);
      };

      MRTClassParam.prototype.fillBase = function(value, type, key) {
        if (this.isEmpty(value)) {
          return this._base[type][key];
        } else {
          return value;
        }
      };

      MRTClassParam.prototype.fill = function(param, type, dbg) {
        var key;
        if (param == null) {
          param = null;
        }
        if (type == null) {
          type = null;
        }
        if (dbg == null) {
          dbg = true;
        }
        param = param != null ? copy(param) : {};
        if (type != null) {
          for (key in this._base[type]) {
            param[key] = this.fillBase(param[key], type, key);
            param[key] = Array.isArray(param[key]) ? pickFrom(param[key]) : getClass(param[key]) === 'Function' ? param[key]() : param[key];
          }
          if (dbg) {
            this.root.dbg.set(type, param);
          }
        } else {
          for (type in this._base) {
            param[type] = this.fill(param[type], type);
          }
        }
        return param;
      };

      return MRTClassParam;

    })(MRTClass);

    MRT.prototype.Debugger = function() {
      return new MRTClassDebugger(this);
    };

    MRT.prototype.MRTClassDebugger = MRTClassDebugger = (function(_super) {
      __extends(MRTClassDebugger, _super);

      MRTClassDebugger.prototype.debug_values = null;

      function MRTClassDebugger(root) {
        MRTClassDebugger.__super__.constructor.call(this, root);
        this.clear();
      }

      MRTClassDebugger.prototype._parse_param = function(val, f) {
        var v, _i, _len, _ref, _results;
        if (contains(val, ',')) {
          _ref = val.split(',');
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            v = _ref[_i];
            _results.push(f(v));
          }
          return _results;
        } else {
          return f(val);
        }
      };

      MRTClassDebugger.prototype.parseParamInt = function(val) {
        return this._parse_param(val, parseInt);
      };

      MRTClassDebugger.prototype.parseParamDec = function(val) {
        return this._parse_param(val, parseFloat);
      };

      MRTClassDebugger.prototype.getSequenceParam = function(fill, show) {
        var param;
        if (fill == null) {
          fill = true;
        }
        if (show == null) {
          show = true;
        }
        param = {
          trials_per_condition: this.parseParamInt($('#sequence_trials_per_condition').val()),
          match_ratio: this.parseParamDec($('#sequence_match_ratio').val()),
          interleave_norotation: $('#sequence_interleave_norotation').data('state')
        };
        if (fill) {
          return this.root.param.fill(param, 'sequence', show);
        } else {
          return param;
        }
      };

      MRTClassDebugger.prototype.getTrialParam = function(fill, show) {
        var param;
        if (fill == null) {
          fill = true;
        }
        if (show == null) {
          show = true;
        }
        param = {
          duration: this.parseParamInt($('#trial_duration').val()),
          target_delay: this.parseParamInt($('#trial_target_delay').val()),
          iti: this.parseParamInt($('#trial_iti').val())
        };
        if (fill) {
          return this.root.param.fill(param, 'trial', show);
        } else {
          return param;
        }
      };

      MRTClassDebugger.prototype.getStimulusParam = function(fill, show) {
        var param, _ref, _ref1, _ref2;
        if (fill == null) {
          fill = true;
        }
        if (show == null) {
          show = true;
        }
        param = {
          match: $('#stimulus_match').data('state'),
          idx: this.parseParamInt($('#stimulus_idx').val()),
          rotate_dir: $('#stimulus_rotate_dir').val(),
          rotate_angle: this.parseParamInt($('#stimulus_rotate_angle').val()),
          show_angle: $('#stimulus_show_angle').data('state'),
          position: this.parseParamInt($('#stimulus_position').val()),
          flip_x: (_ref = $('#stimulus_flip_x').data('state')) != null ? _ref : [false, true],
          flip_y: (_ref1 = $('#stimulus_flip_y').data('state')) != null ? _ref1 : [false, true],
          flip_z: (_ref2 = $('#stimulus_flip_z').data('state')) != null ? _ref2 : [false, true],
          cube_size: this.parseParamInt($('#stimulus_cube_size').val()),
          offset: this.parseParamInt($('#stimulus_offset').val()),
          edge: this.parseParamInt($('#stimulus_edge').val()),
          font_size: this.parseParamInt($('#stimulus_font_size').val())
        };
        if (fill) {
          return this.root.param.fill(param, 'stimulus', show);
        } else {
          return param;
        }
      };

      MRTClassDebugger.prototype.getParam = function(fill, show) {
        if (fill == null) {
          fill = true;
        }
        if (show == null) {
          show = true;
        }
        return {
          sequence: this.getSequenceParam(fill, show),
          trial: this.getTrialParam(fill, show),
          stimulus: this.getStimulusParam(fill, show)
        };
      };

      MRTClassDebugger.prototype.showStimulus = function() {
        var param;
        param = this.getStimulusParam();
        this.root.session.clearStimulus();
        return this.root.session.showStimulus(param, true);
      };

      MRTClassDebugger.prototype.doTrial = function() {
        var param;
        param = this.getParam();
        this.root.session.clearStimulus();
        return this.root.session.doTrial(param);
      };

      MRTClassDebugger.prototype.run = function() {
        this.clear();
        return this.root.session.run(this.getParam(false, false));
      };

      MRTClassDebugger.prototype.showSequence = function() {
        var param, seq;
        param = this.getParam(false, false);
        this.root.session.setSequence(param);
        seq = this.root.session.getSequence();
        return this.set({
          sequence: seq
        }, null, true);
      };

      MRTClassDebugger.prototype.showDuration = function() {
        var param, tTotal, trial;
        if (this.root.debug) {
          param = this.getParam(false, false);
          this.root.session.setSequence(param);
          trial = this.root.param.fill(param.trial, 'trial', false);
          tTotal = this.root.session.getSequence().length * (trial.duration + trial.iti) - trial.iti;
          this.clear('sequence');
          return this.set('exp_duration', "" + (tTotal / (1000 * 60)) + " min.");
        }
      };

      MRTClassDebugger.prototype.get = function(key) {
        if (key == null) {
          key = null;
        }
        if (key != null) {
          return this.debug_values[key];
        } else {
          return this.debug_values;
        }
      };

      MRTClassDebugger.prototype.set = function(key, value, override) {
        if (value == null) {
          value = null;
        }
        if (override == null) {
          override = false;
        }
        if (override) {
          this.clear();
        }
        switch (getClass(key)) {
          case 'String':
            this.debug_values[key] = value;
            break;
          case 'Object':
            this.debug_values = merge(this.debug_values, key);
            break;
          default:
            throw 'invalid key';
        }
        this.disp();
        return value;
      };

      MRTClassDebugger.prototype.step = function(key) {
        var _ref;
        return this.set(key, ((_ref = this.get(key)) != null ? _ref : 0) + 1);
      };

      MRTClassDebugger.prototype.timestamp = function(key) {
        return this.set(key, this.root.time.Now());
      };

      MRTClassDebugger.prototype.clear = function(key) {
        if (key == null) {
          key = null;
        }
        if (key != null) {
          if (getClass(key) === 'String') {
            delete this.debug_values[key];
          }
        } else {
          this.debug_values = {};
        }
        return this.disp();
      };

      MRTClassDebugger.prototype.disp = function() {
        if (this.root.debug) {
          return $('#debug-info').html(obj2str(this.debug_values));
        }
      };

      MRTClassDebugger.prototype.test = function() {
        var x;
        x = [1, 2, 3, 4];
        return alert(x.slice(1));
      };

      return MRTClassDebugger;

    })(MRTClass);

    return MRT;

  })();

}).call(this);
